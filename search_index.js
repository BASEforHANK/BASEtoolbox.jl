var documenterSearchIndex = {"docs":
[{"location":"SteadyState/#Computation-of-the-steady-state-and-dimensionality-reduction","page":"Steady state","title":"Computation of the steady state and dimensionality reduction","text":"","category":"section"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"note: Note\nMost of the code of this section is in the submodule SteadyState (src/SubModules/SteadyState/), except for  prepare_linearization(), which is generated by the preprocessor and can be found in src/Preprocessor/generated_fcns/prepare_linearization_generated.jl. The preprocessor uses the template stored as src/Preprocessor/template_fcns/prepare_linearization.jl.","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"The model features uninsured income shocks y (by assumption, all workers supply the same efficiency units of labor [BBL], so idiosyncratic productivity shocks translate to income shocks) and two assets, liquid assets (bonds) m and illiquid assets (capital) k. Entrepreneurs (last income-state) receive no labor income, but firm profits, while workers additionally receive labor union profits.","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"The steady state equilibrium contains, aside from the capital stock, marginal value functions V_m and V_k on a three-dimensional grid (m times k times y) and the ergodic joint distribution over these idiosyncratic states. We do dimensionality reduction [BL] by applying the Discrete Cosine Transformation to the marginal value functions and approximating the joint distribution with a copula and state-dependent marginals.","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"The main functions are call_find_steadystate() and call_prepare_linearization(), with compute_steadystate() being a wrapper for both of them.","category":"page"},{"location":"SteadyState/#compute_steadystate","page":"Steady state","title":"compute_steadystate","text":"","category":"section"},{"location":"SteadyState/#BASEforHANK.compute_steadystate","page":"Steady state","title":"BASEforHANK.compute_steadystate","text":"compute_steadystate(m_par)\n\nA wrapper for call_find_steadystate() and call_prepare_linearization().\n\nArguments\n\nm_par::ModelParameters\n\nReturns\n\nSteadyResults, containing returns of prepare_linearization()\n\n\n\n\n\n","category":"function"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"Combines steady state computation and preparation of linearization in one function call. It has the same returns as call_prepare_linearization().","category":"page"},{"location":"SteadyState/#call_find_steadystate","page":"Steady state","title":"call_find_steadystate","text":"","category":"section"},{"location":"SteadyState/#BASEforHANK.call_find_steadystate","page":"Steady state","title":"BASEforHANK.call_find_steadystate","text":"call_find_steadystate(m_par)\n\nComputes the steady state of the household problem and fills the SteadyStateStruct struct (without further steps of preparing the linearization).\n\nArguments\n\nm_par::ModelParameters\n\nReturns\n\nSteadyStateStruct, containing returns of find_steadystate()\n\n\n\n\n\n","category":"function"},{"location":"SteadyState/#BASEforHANK.SteadyState.find_steadystate","page":"Steady state","title":"BASEforHANK.SteadyState.find_steadystate","text":"find_steadystate(m_par)\n\nFind the stationary equilibrium capital stock as well as the associated marginal value functions and the stationary distribution of idiosyncratic states.\n\nThis function solves for the market clearing capital stock in the Aiyagari model with idiosyncratic income risk. That is, it uses CustomBrent() to find the root of the excess capital demand function, which is defined in Kdiff(). It does so first on a coarse grid and then on the actual grid.\n\nArguments\n\nm_par::ModelParameters\n\nReturns\n\nKSS: Steady-state capital stock\nWbSS, WkSS: Marginal value functions\ndistrSS::Array{Float64,3}: Steady-state distribution of idiosyncratic states, computed by Ksupply()\nn_par::NumericalParameters, m_par::ModelParameters\n\n\n\n\n\n","category":"function"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"The function takes the parameter struct ModelParameters as input m_par (see Parameters).","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"To find the stationary equilibrium, we proceed in roughly the following steps:","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"Instantiate the parameter struct NumericalParameters as n_par (see Parameters). Within the struct, we set the number of income states [nh] and use the BASEforHANK.Tools.Tauchen() method to obtain a grid and a transition matrix of income, given the autocorrelation of the income process [m_par.ρ_h]. Then, include entrepreneurial state.\nFind equilibrium capital stock (by finding a root of BASEforHANK.SteadyState.Kdiff()), where  the supply of capital by households is calculated in BASEforHANK.SteadyState.Ksupply().\nKsupply() uses the Endogenous Grid Method (see BASEforHANK.SteadyState.EGM_policyupdate()) to iteratively obtain optimal policies and marginal value functions. The supply of capital by households is then computed based on the eigenvector associated with the unit eigenvalue of the transition matrix that comes out of the households' policies.\nRoot finding is performed using Brent's method where the customized algorithm generates initial guesses for value functions and distributions based on previous iterations in the root finding.","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"This procedure is performed twice: First for a coarse grid (specified in the function) and then for the user-specified grid up to the user-desired precision [n_par.ϵ] (both defined in the Parameters).","category":"page"},{"location":"SteadyState/#call_prepare_linearization","page":"Steady state","title":"call_prepare_linearization","text":"","category":"section"},{"location":"SteadyState/#BASEforHANK.call_prepare_linearization","page":"Steady state","title":"BASEforHANK.call_prepare_linearization","text":"call_prepare_linearization(ss, m_par)\n\nPrepares linearization and fills the SteadyResults struct.\n\nArguments\n\nss::SteadyStateStruct: Output of call_find_steadystate()\nm_par::ModelParameters\n\nReturns\n\nSteadyResults, containing returns of prepare_linearization()\n\n\n\n\n\n","category":"function"},{"location":"SteadyState/#BASEforHANK.PerturbationSolution.prepare_linearization","page":"Steady state","title":"BASEforHANK.PerturbationSolution.prepare_linearization","text":"prepare_linearization(K, Wb, Wk, distr, n_par, m_par)\n\nGiven the stationary equilibrium of the household side, computed in find_steadystate(), this function performs several steps:\n\nStep 1: compute the stationary equilibrium.\nStep 2: perform the dimensionality reduction of the marginal value functions as well as the distribution.\nStep 3: compute the aggregate steady state from input_aggregate_steady_state.mod.\nStep 4: produce indexes to access the variables in the linearized model.\nStep 5: return the results.\n\nArguments\n\nK::Float64: steady-state capital stock\nWb::Array{Float64,3}, Wk::Array{Float64,3}: steady-state marginal value functions\ndistr::Array{Float64,3}: steady-state distribution of idiosyncratic states\nn_par::NumericalParameters,m_par::ModelParameters\n\nReturns\n\nXSS::Array{Float64,1}, XSSaggr::Array{Float64,1}: steady state vectors produced by @writeXSS()\nindexes, indexes_aggr: structs for accessing XSS,XSSaggr by variable names, produced by @make_fn(), @make_fnaggr()\ncompressionIndexes::Array{Array{Int,1},1}: indexes for compressed marginal value functions (V_m and V_k)\nn_par::NumericalParameters, m_par::ModelParameters: updated parameters\nCDFSS, CDF_bSS, CDF_kSS, CDF_hSS: cumulative distribution functions (joint and marginals)\ndistrSS::Array{Float64,3}: steady state distribution of idiosyncratic states, computed by Ksupply()\n\n\n\n\n\n","category":"function"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"We first calculate other equilibrium quantities and produce distributional summary statistics (BASEforHANK.Tools.distrSummaries()). Next, we reduce the dimensionality:","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"Find the sparse representation of fluctuations of V_m and V_k around the steady state. For this purpose,  calculate the derivatives of V_m and V_k with respect to all prices  that enter the household problem. Then transform these derivatives using the  Discrete Cosine Transformation (Julia-package FFTW) into polynomial coefficients.  Calculate the average absolute value of those coefficients and retain those that explain a large  share of the variance of coefficients (up to 100*(1-n_par.reduc_marginal_value) percent).  Add, in the same way, polynomial coefficients that explain  V_m and V_k themselves.  The quality of the latter approximation is controlled by n_par.reduc_value.  The corresponding indices are saved in compressionIndexes. This whole step  is being done in first_stage_reduction().\nPrepare a node mesh on which the time-varying linear interpolant of the copula   is defined. The grid in each m, k, and y dimension is selected   such that each resulting bin holds approximately the same share of the   respective aggregate variable.","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"Lastly, we collect the steady-state values of all model variables in the vector XSS (see BASEforHANK.Parsing.@writeXSS). The state variables consist of the marginal distributions over m, k and y and the aggregate state variables (collected in state_names). The control variables consist of the steady state marginal value functions (over the full grid) and the aggregate control variables (collected in control_names; these vectors are defined in the main script BASEforHANK.jl).","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"While the steady-state marginal value functions have full dimensionality, in the vectors that collect deviations from steady state (in BASEforHANK.PerturbationSolution.Fsys(), those are X and XPrime) only the coefficients of the most important Chebyshev polynomials are saved. Additionally, the deviations of the marginal distributions are saved with one entry short of the grid size, since the marginals are restricted to sum up to 1. We manage this by creating the struct indexes (using BASEforHANK.Parsing.@make_fn), that has two fields for each variable: steady state value and deviation.","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"We also construct the vector XSSaggr and the struct indexes_aggr, which are similar to the above but only store (and manage) aggregate variables. This is useful for differentiating only with respect to aggregate variables in the estimation part (see BASEforHANK.PerturbationSolution.LinearSolution_reduced_system()).","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"warning: Warning\nIf you change the household decision model and hence need to customize the steady state solution, you will need to adjust the template Preprocessor/template_fcns/prepare_linearization.jl and not Preprocessor/generated_fcns/prepare_linearization_generated.jl which will be overwritten by the model parser based on Preprocessor/template_fcns/prepare_linearization.jl. Note that the \"definition\" of the function (right click in VSCode) in the module is the generated one.","category":"page"},{"location":"SteadyState/#Parameters","page":"Steady state","title":"Parameters","text":"","category":"section"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"The model parameters for the steady state have to be calibrated. We set them in the struct ModelParameters. It also contains all other parameters that are estimated, including the stochastic process-parameters for the aggregate shocks.","category":"page"},{"location":"SteadyState/#BASEforHANK.Parsing.ModelParameters","page":"Steady state","title":"BASEforHANK.Parsing.ModelParameters","text":"ModelParameters()\n\nA structure to collect all model parameters, including calibrated values and prior distributions for estimation.\n\nOverview\n\nThis struct is designed for macroeconomic models and includes parameters related to household preferences, income processes, technological factors, monetary policy, fiscal policy, and exogenous shocks.\nThe parameters are annotated with metadata such as names (both ASCII and LaTeX), prior distributions, and a boolean flag indicating whether they are estimated.\nUses the Parameters, FieldMetadata, and Flatten packages to facilitate parameter management.\n\nFields\n\nEach field follows the structure:\n\nparameter::T = value | \"ascii_name\" | L\"latex_name\" | prior_distribution | estimated\n\nparameter: Internal model parameter name.\nvalue: Default numerical value.\nascii_name: Human-readable name used in output or logging.\nlatex_name: Corresponding LaTeX notation for use in reports and documentation.\nprior_distribution: Prior distribution for Bayesian estimation (if applicable).\nestimated: Boolean indicating whether the parameter is estimated.\n\n\n\n\n\n","category":"type"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"The numerical parameters contain the grid (and the meshes) on which the stationary equilibrium is solved, discretization results of call_find_steadystate() like the transition matrix of income and the joint distribution, and other parameters that determine the numerical approximation or solution technique, like reduc or sol_algo.","category":"page"},{"location":"SteadyState/#BASEforHANK.Parsing.NumericalParameters","page":"Steady state","title":"BASEforHANK.Parsing.NumericalParameters","text":"NumericalParameters()\n\nCollect parameters for the numerical solution of the model in a struct.\n\n\n\n\n\n","category":"type"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"In particular, nh, nk, and nb control the resolution for the income, illiquid asset, and liquid asset grid. The resolution of the copula used in the linearization does not need to coincide with that grid and is controlled by nh_copula, nk_copula, and nb_copula, respectively. Note, however, that the copula resolution should not exceed the actual grid size.","category":"page"},{"location":"SteadyState/#Find-stationary-equilibrium:-functions","page":"Steady state","title":"Find stationary equilibrium: functions","text":"","category":"section"},{"location":"SteadyState/#BASEforHANK.SteadyState.Kdiff","page":"Steady state","title":"BASEforHANK.SteadyState.Kdiff","text":"Kdiff(\n    KD,\n    n_par,\n    m_par,\n    initialize = true,\n    Wb_guess = zeros(1, 1, 1),\n    Wk_guess = zeros(1, 1, 1),\n    distr_guess = zeros(1, 1, 1)\n)\n\nThis function is used to find the stationary equilibrium of the household block of the model, in particular, it is used in find_steadystate().\n\nCalculate the difference between the capital stock that is demanded/assumed (KD) and the capital stock that prevails under that demanded capital stock's implied prices when households face idiosyncratic income risk (Aiyagari model).\n\nRequires global functions from the IncomesETC module and Ksupply().\n\nArguments\n\nKD::Float64: Assumed capital demand (guess)\nn_par::NumericalParameters, m_par::ModelParameters\ninitialize::Bool = true: If true, initialize the marginal value functions and   stationary distribution, otherwise use the provided guesses that follow. Providing the   guesses can be used in CustomBrent() to speed up the solution since the   results from the previous iteration can be used as starting values.\nWb_guess::AbstractArray = zeros(1, 1, 1): Guess for marginal value of liquid assets\nWk_guess::AbstractArray = zeros(1, 1, 1): Guess for marginal value of illiquid   assets\ndistr_guess::AbstractArray = zeros(1, 1, 1): Guess for stationary distribution\n\nReturns\n\ndiff::Float64: Difference between the demanded and supplied capital stock\nWb::AbstractArray: Marginal value of liquid assets, implied by capital demand\nWk::AbstractArray: Marginal value of illiquid assets, implied by capital demand\ndistr::AbstractArray: Stationary distribution of idiosyncratic states, implied by   capital demand\n\n\n\n\n\n","category":"function"},{"location":"SteadyState/#BASEforHANK.SteadyState.Ksupply","page":"Steady state","title":"BASEforHANK.SteadyState.Ksupply","text":"Ksupply(\n    args_hh_prob,\n    n_par,\n    m_par,\n    Wb,\n    Wk,\n    distr_guess,\n    net_income,\n    eff_int,\n)\n\nCalculate the aggregate savings when households face idiosyncratic income risk by first solving the household problem using the endogenous grid method (EGM) and then finding the stationary distribution of idiosyncratic states.\n\nIdiosyncratic state is tuple (b,k,y), where:\n\nb: liquid assets,\nk: illiquid assets,\ny: labor income.\n\nThis function is used in find_steadystate() to find the stationary equilibrium, as an input to Kdiff(), and in BASEforHANK.PerturbationSolution.prepare_linearization() to prepare the linearization of the model.\n\nArguments\n\nargs_hh_prob: Vector of arguments to the household problem\nRK_guess: gross real interest rate illiquid assets\nn_par, m_par\nWb, Wk: guess for marginal value functions\ndistr_guess: guess for stationary distribution\nnet_income: incomes, output of functions from the IncomesETC module\neff_int: effective interest rate, output of functions from the IncomesETC module\n\nReturns\n\nK,B: aggregate saving in illiquid (K) and liquid (B) assets\nΓ,Γ_a,Γ_n: sparse transition matrices (average, with [a] or without [n] adjustment of illiquid asset)\nx_a_star,b_a_star,k_a_star,x_n_star,b_n_star: optimal policies for consumption [c], liquid [m] and illiquid [k] asset, with [a] or without [n] adjustment of illiquid asset\nWb,Wk: marginal value functions\ndistr: ergodic steady state of Γ\n\n\n\n\n\n","category":"function"},{"location":"SteadyState/#BASEforHANK.SteadyState.EGM_policyupdate","page":"Steady state","title":"BASEforHANK.SteadyState.EGM_policyupdate","text":"EGM_policyupdate(\n    EWbPrime::Array,\n    EWkPrime::Array,\n    args_hh_prob::Vector,\n    net_income::Array,\n    n_par,\n    m_par,\n    warnme::Bool,\n    model::Union{CompleteMarkets,OneAsset,TwoAsset},\n)\n\nFind optimal policies, given tomorrows marginal continuation values EWbPrime, EWkPrime, today's prices [args_hh_prob], and income [net_income], using the Endogenous Grid Method.\n\nOptimal policies are defined over the exogenously fixed grid, while values of optimal policies (b and k) can have off-grid values. Please refer to the subsection with the title 'Update the optimal policy functions' of the document 'Computational Notes.md', for a detailed explanation of the function's code. The FOC's mentioned in the code are the Euler Equations as in the 'documentation of the household problem'.\n\nArguments\n\nEWbPrime, EWkPrime: Marginal continuation values of liquid and illiquid assets\nargs_hh_prob: Vector of arguments to the household problem\nnet_income: Incomes, output of functions from the IncomesETC module\nn_par, m_par\nwarnme: If true, warns about non-monotonicity in resources or liquid asset choices\nmodel: Model type, either CompleteMarkets, OneAsset, or TwoAsset\n\nReturns\n\nx_a_star,b_a_star,k_a_star,x_n_star,b_n_star: Optimal (on-grid) policies for the composite [x], liquid [b] and illiquid [k] asset, with [a] or without [n] adjustment of illiquid asset\n\n\n\n\n\n","category":"function"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"[BBL]: For details, see the paper Shocks, Frictions, and Inequality in US Business Cycles, American Economic Review, forthcoming.","category":"page"},{"location":"SteadyState/","page":"Steady state","title":"Steady state","text":"[BL]: For details, see the paper Solving heterogeneous agent models in discrete time with many idiosyncratic states by perturbation methods, Quantitative Economics, Vol.11(4), November 2020, p. 1253-1288.","category":"page"},{"location":"examples/simpler_hank/#Simpler-HANK-model","page":"Simpler HANK model","title":"Simpler HANK model","text":"","category":"section"},{"location":"examples/simpler_hank/#Equations","page":"Simpler HANK model","title":"Equations","text":"","category":"section"},{"location":"examples/simpler_hank/#Shocks","page":"Simpler HANK model","title":"Shocks","text":"","category":"section"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\nlog textRshock_t+1 = rho_textRshock log textRshock_t \nlog textA_t+1 = rho_textA log textA_t \nlog sigma_t+1 = rho_s log sigma_t\nendalign","category":"page"},{"location":"examples/simpler_hank/#Lags","page":"Simpler HANK model","title":"Lags","text":"","category":"section"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\nlog B_textgovlagt+1 = log B_textgovt \nlog I_textlagt+1 = log I_t \nlog w_textlagt+1 = log w_t \nlog tau_textavglagt+1 = log tau_textavgt \nlog tau_textproglagt+1 = log tau_textprogt \nlog qPi_textlagt+1 = log qPi_t\nendalign","category":"page"},{"location":"examples/simpler_hank/#Actual-equations","page":"Simpler HANK model","title":"Actual equations","text":"","category":"section"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Monetary policy rule","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\nlog RB_t+1 = RB  + theta_pi log pi_t + log textRshock_t\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Deficit rule and government budget constraint","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\nlog B_textgovt+1 = log B_textgovt \nlog G_t = log left( B_textgovt+1 + T_t - fracRB_tpi_t B_textgovt right)\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Price Phillips curve","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    log pi_t - pi = kappa left(mc_t - frac1mu right) + beta left(( log pi_t+1 - pi) fracY_t+1Y_t right)\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Wage Phillips curve","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    log pi_wt - pi_w = kappa_w left(mc_wt - frac1mu_w right) + beta left(( log pi_wt+1 - pi_w) fracN_t+1 w_t+1N_t w_t right)\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Real wage inflation","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    log fracw_tw_t-1 = log fracpi_wtpi_t\nendalign","category":"page"},{"location":"examples/simpler_hank/#Firms:-Intermediate-goods-producers","page":"Simpler HANK model","title":"Firms: Intermediate goods producers","text":"","category":"section"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Intermediate goods producers minimize the costs of production w_t N_t + (r_t - 1 + q_t delta_0) K_t subject to the production function Y_t = K_t^alpha N_t^1-alpha. Hence, the first order conditions are","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    r_t = alpha textmc_t left( fracK_tN_t right)^alpha-1 + 1 - q_t delta_0 \n    w_t = (1-alpha) textmc_t left( fracK_tN_t right)^alpha\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Union profits","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    log Pi^U_t = log left( w_t N_t (1 - textmc_wt ) right)\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Firm profits","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    log Pi^F_t = log left( Y_t (1-textmc_t) + q_t left(K_t+1- (1 - delta_0) K_t right) - I_t right)\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Value of profit shares","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    log left( fractextRB_t+1pi_t+1 right) = log left( frac(1-iota) (q^Pi_t - 1) + omega Pi^F_tq^Pi_t - 1 right)\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Return on liquid assets","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    log textRL_t = log left( fractextRB_t B_textgovt + pi_t left( (1-iota) (q^Pi_t - 1) + omega Pi^F_t right)B_t right)\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Total liquid assets","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    log B_t = log left( B_textgovt + q^Pi_t - 1 right)\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Capital price","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    q_t = 1\nendalign","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"Capital accumulation","category":"page"},{"location":"examples/simpler_hank/","page":"Simpler HANK model","title":"Simpler HANK model","text":"beginalign\n    K_t+1 = I_t + (1 - delta_0) K_t\nendalign","category":"page"},{"location":"PerturbationSolution/#Linear-perturbation-around-steady-state","page":"Perturbation solution","title":"Linear perturbation around steady state","text":"","category":"section"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"note: Note\nThe main functions of this section are in the Submodule PerturbationSolution.","category":"page"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"The model is linearized with respect to aggregate variables. For this, we write the equilibrium conditions in the form of F(XX)=0, where X and X are (expected) deviations from steady state in two successive periods. Applying the total differential yields A*X = - B*X, where A,B are the first derivatives of F with respect to X,X. In the standard setting, we use the generalized Schur decomposition [Klein] to transform this equation into a linearized observation equation d = gx*k and a linearized state transition equation k = hx*k, where k is a vector of the state variables and d is a vector of the control variables, X = beginbmatrix k  d endbmatrix.","category":"page"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"In our code, F is implemented as BASEforHANK.PerturbationSolution.Fsys(), while differentiating and solving for gx and hx is done in BASEforHANK.PerturbationSolution.LinearSolution(), called by linearize_full_model() returns the results as a struct LinearResults:","category":"page"},{"location":"PerturbationSolution/#linearize_full_model()","page":"Perturbation solution","title":"linearize_full_model()","text":"","category":"section"},{"location":"PerturbationSolution/#BASEforHANK.linearize_full_model","page":"Perturbation solution","title":"BASEforHANK.linearize_full_model","text":"linearize_full_model(sr, m_par; ss_only = false)\n\nLinearize the full model (i.e. including idiosyncratic states and controls) around the steady state, and solves using LinearSolution().\n\nArguments\n\nsr::SteadyResults: Output of call_prepare_linearization()\nm_par::ModelParameters\nss_only::Bool: If true, only the steady state is checked\n\nReturns\n\nLinearResults, containing\nState2Control::Array{Float64,2}: Matrix of observation equation\nLOMstate::Array{Float64,2}: Matrix of state transition equation\nA::Array{Float64,2},B::Array{Float64,2}: First derivatives of PerturbationSolution.Fsys() with respect to arguments X [B] and XPrime [A]\n\n\n\n\n\n","category":"function"},{"location":"PerturbationSolution/#BASEforHANK.PerturbationSolution.LinearSolution","page":"Perturbation solution","title":"BASEforHANK.PerturbationSolution.LinearSolution","text":"LinearSolution(sr, m_par, A, B; allow_approx_sol = true, ss_only = false)\n\nCalculate the linearized solution to the non-linear difference equations defined by function Fsys(), using Schmitt-Grohé & Uribe (JEDC 2004) style linearization (apply the implicit function theorem to obtain linear observation and state transition equations).\n\nThe Jacobian is calculated using the package ForwardDiff\n\nArguments\n\nsr: steady-state structure (variable values, indexes, numerical parameters, ...)\nA,B: derivative of Fsys() with respect to arguments X [B] and   XPrime [A]\nm_par: model parameters\nallow_approx_sol: if true, the function will attempt to solve the linearized model   even if the system is indeterminate (shifting the critical eigenvalues)\nss_only: if true, the function will only check if the steady state is a solution\n\nReturns\n\ngx,hx: observation equations [gx] and state transition equations [hx]\nalarm_LinearSolution,nk: alarm_LinearSolution=true when solving algorithm fails, nk number of   predetermined variables\nA,B: first derivatives of Fsys() with respect to arguments X [B] and   XPrime [A]\n\n\n\n\n\n","category":"function"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"The function linearize_full_model() calls LinearSolution and stores the results in a LinearResults struct.","category":"page"},{"location":"PerturbationSolution/#LinearSolution()","page":"Perturbation solution","title":"LinearSolution()","text":"","category":"section"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"The LinearSolution function executes the following steps:","category":"page"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"generate devices to retrieve distribution and marginal value functions from   compressed states/controls (Γ and DC,IDC)\ncalculate the first derivative of BASEforHANK.PerturbationSolution.Fsys() with respect to X and XPrime.   We use automatic differentiation (implemented in Julia by the package ForwardDiff).   Partial derivatives are calculated using the ForwardDiff.jacobian() function.   We exploit that some partial derivatives have known values (contemporaneous marginal value   functions and the future marginal distributions) and set them directly instead of calculating them [BL].\ncompute linear observation and state transition equations using the BASEforHANK.PerturbationSolution.SolveDiffEq() function","category":"page"},{"location":"PerturbationSolution/#SolveDiffEq()","page":"Perturbation solution","title":"SolveDiffEq()","text":"","category":"section"},{"location":"PerturbationSolution/#BASEforHANK.PerturbationSolution.SolveDiffEq","page":"Perturbation solution","title":"BASEforHANK.PerturbationSolution.SolveDiffEq","text":"SolveDiffEq(A, B, n_par; allow_approx_sol)\n\nCalculate the solution to the linearized difference equations defined as P'BP xt = P'AP x{t+1}, where P is the (ntotal x r) semi-unitary model reduction matrix n_par.PRightAll of potentially reduced rank r.\n\nArguments\n\nA,B: matrices with first derivatives\nn_par::NumericalParameters: n_par.sol_algo determines   the solution algorithm, options are:\nlitx:  Linear time iteration (implementation follows Reiter)\nschur: Klein's algorithm (preferable if number of controls is small)\nallow_approx_sol: if true approximate solutions are allowed if the system is not unique and determinate\n\nReturns\n\ngx,hx: observation equations [gx] and state transition equations [hx]\nalarm_LinearSolution,nk: alarm_LinearSolution=true when solving algorithm fails, nk number of   predetermined variables\n\n\n\n\n\n","category":"function"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"apply the model reduction by pre- and post-multiplying the reduction matrix mathcalP to the Jacobians A and B that are inputs to BASEforHANK.PerturbationSolution.SolveDiffEq(). mathcalP is calculated in model_reduction() and stored in n_par.PRightAll.\ncompute linear observation and state transition equations. The solution algorithm is set   in n_par.sol_algo, with the options :schur (mentioned above) and :litx [lit]. The results are matrices that map contemporaneous states to controls [gx],   or contemporaneous states to future states [hx]","category":"page"},{"location":"PerturbationSolution/#Fsys()","page":"Perturbation solution","title":"Fsys()","text":"","category":"section"},{"location":"PerturbationSolution/#BASEforHANK.PerturbationSolution.Fsys","page":"Perturbation solution","title":"BASEforHANK.PerturbationSolution.Fsys","text":"Fsys(X, XPrime, XSS, m_par, n_par, indexes, Γ, compressionIndexes, DC, IDC, DCD, IDCD; only_F = true)\n\nEquilibrium error function: returns deviations from equilibrium around steady state.\n\nSplit computation into Aggregate Part, handled by Fsys_agg() and Heterogeneous Agent Part.\n\nArguments\n\nX,XPrime: deviations from steady state in periods t [X] and t+1 [XPrime]\nXSS: states and controls in steady state\nΓ, DC, IDC, DCD,IDCD: transformation matrices to retrieve:\nmarginal distributions [Γ],\nmarginal value functions [DC,IDC], and\nthe (linear) interpolant of the copula [DCD,IDCD] from deviations\nindexes,compressionIndexes: access XSS by variable names (DCT coefficients of compressed V_m and V_k in case of compressionIndexes)\n\n\n\n\n\n","category":"function"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"The function BASEforHANK.PerturbationSolution.Fsys() proceeds in the following way:","category":"page"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"set up vector F, that contains the errors to all equilibrium conditions. There are as many conditions  as deviations from steady state (length of X,XPrime), and conditions are indexed with  respective model variable in IndexStruct indexes\ngenerate locally all aggregate variables (for both periods) using BASEforHANK.Parsing.@generate_equations\nconstruct the full-grid marginal distributions, marginal value functions, and the copula  from the steady-state values and the (compressed) deviations (for the copula, the selection of DCT  coefficients that can be perturbed ensures that also the perturbed function is a copula)\nwrite all equilibrium condition-errors with respect to aggregate variables to F, using  BASEforHANK.PerturbationSolution.Fsys_agg()\ncompute optimal policies with BASEforHANK.SteadyState.EGM_policyupdate(), given  future marginal value functions, prices, and individual incomes. Infer present marginal  value functions from them (envelope theorem) and set the difference to assumed present  marginal value functions (in terms of their compressed deviation from steady state)  as equilibrium condition-errors (backward iteration of the value function)\ncompute future marginal distributions and the copula (on the copula grid) from previous distribution and optimal asset policies. Interpolate when necessary. Set difference to assumed future marginal distributions and copula values on the copula nodes as equilibrium condition-errors (forward iteration of the distribution)\ncompute distribution summary statistics with BASEforHANK.Tools.distrSummaries() and write  equilibrium conditions with their respective (control) variables\nreturn F","category":"page"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"Note that the copula is treated as the sum of two interpolants. An interpolant based on the steady-state distribution using the full steady-state marginals as a grid and a \"deviations\"-function that is defined on the copula grid generated in prepare_linearization(). The actual interpolation is carried out with BASEforHANK.Tools.myinterpolate3(). Default setting is trilinear interpolation, the code also allows for 3d-Akima interpolation.","category":"page"},{"location":"PerturbationSolution/#model_reduction()","page":"Perturbation solution","title":"model_reduction()","text":"","category":"section"},{"location":"PerturbationSolution/#BASEforHANK.PerturbationSolution.model_reduction","page":"Perturbation solution","title":"BASEforHANK.PerturbationSolution.model_reduction","text":"model_reduction()\n\nProduce Model Reduction based on Variance Covariance Matrix of States and Controls.\n\nReturns/ Updates\n\nSteadyResults, containing returns of find_steadystate()\n\n\n\n\n\n","category":"function"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"The function model_reduction() derives the approximate factor representation from a first solution of the heterogeneous agent model.[BBL] It then stores the matrices that allow to map the factors to the full set of state and control variables. For deriving the factor representation, the function calculates the long run variance-covariance matrix of all states of the model (given its first-stage reduction).","category":"page"},{"location":"PerturbationSolution/#update_model()","page":"Perturbation solution","title":"update_model()","text":"","category":"section"},{"location":"PerturbationSolution/#BASEforHANK.PerturbationSolution.update_model","page":"Perturbation solution","title":"BASEforHANK.PerturbationSolution.update_model","text":"update_model()\n\nUpdates the linearized model (around the steady state, after parameter changes in the aggregate model) and solves, using LinearSolution_reduced_system(). WARNING: The function is not threadsafe in the sense that calling it will alter the input(!) lr.A/B across threads, if lr is not local to the thread.\n\nReturns\n\nLinearResults, containing\n\nA::Array{Float64,2},B::Array{Float64,2}: first derivatives of Fsys() with   respect to arguments X [B] and XPrime [A]\nState2Control::Array{Float64,2}: observation equation\nLOMstate::Array{Float64,2}: state transition equation\n\n\n\n\n\n","category":"function"},{"location":"PerturbationSolution/#BASEforHANK.PerturbationSolution.Fsys_agg","page":"Perturbation solution","title":"BASEforHANK.PerturbationSolution.Fsys_agg","text":"Fsys_agg(X, XPrime, XSS, distrSS, m_par, n_par, indexes)\n\nReturn deviations from aggregate equilibrium conditions.\n\nindexes can be both IndexStruct or IndexStructAggr; in the latter case (which is how function is called by LinearSolution_reduced_system()), variable-vectors X,XPrime, and XSS only contain the aggregate variables of the model.\n\n\n\n\n\n","category":"function"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"The function update_model() solves the aggregate model without updating the derivatives of the household/idiosyncratic part. For this purpose the derivatives of BASEforHANK.PerturbationSolution.Fsys_agg() are calculated instead of Fsys(). This substantially speeds up the solution after a parameter change that only affects aggregates.[BBL] In particular, if the model is reduced to its approximate factor representation (see above), this generates significant speed gains.","category":"page"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"[Klein]: See the paper Using the generalized Schur form to solve a multivariate linear rational expectations model by Paul Klein (JEDC 2000)","category":"page"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"[BL]: Contemporaneous marginal value functions are irrelevant for optimal decisions, so its effect on other model variables is 0. Due to a rich enough set of prices, the future distribution directly only affects the Fokker-Planck equation. For details, see the paper Solving heterogeneous agent models in discrete time with many idiosyncratic states by perturbation methods, Quantitative Economics, Vol.11(4), November 2020, p. 1253-1288.","category":"page"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"[BBL]: For details, see the paper Shocks, Frictions, and Inequality in US Business Cycles, American Economic Review, forthcoming.","category":"page"},{"location":"PerturbationSolution/","page":"Perturbation solution","title":"Perturbation solution","text":"[lit]: Invoking the Implicit Function Theorem, there exist functions g and h such that Fleft(beginpmatrix k  g(k) endpmatrixbeginpmatrix h(k)  g(h(k)) endpmatrixright)=0. Totally differentiating by k yields B beginpmatrixmathbbI Dg endpmatrix+A beginpmatrixmathbbI Dg endpmatrix Dh = 0. The :lit-algorithm solves this equation for Dg and Dh iteratively.","category":"page"},{"location":"Tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"Tools/","page":"Tools","title":"Tools","text":"The Tools submodule provides a set of numerical subroutines such as linear and non-linear interpolation, the Tauchen algorithm to discretize a Gaussian AR-1 process, root-finders and optimizers, wrappers for the schur decomposition, etc.","category":"page"},{"location":"Tools/#Some-of-the-functions-in-detail","page":"Tools","title":"Some of the functions in detail","text":"","category":"section"},{"location":"Tools/#BASEforHANK.Tools.Tauchen","page":"Tools","title":"BASEforHANK.Tools.Tauchen","text":"Tauchen(rho::Float64, N::Int; sigma::Float64 = 1.0, mue::Float64 = 0.0)\n\nGenerate a discrete approximation to an AR(1) process, following Tauchen (1987).\n\nUses importance sampling: each bin has probability 1/N to realize.\n\nAuthored by Christian Bayer, Uni Bonn, 03.05.2010.\n\nArguments\n\nrho::Float64: autocorrelation coefficient\nN::Int: number of gridpoints\nsigma::Float64: long-run variance\nmue::Float64: mean of the AR(1) process\n\nReturns\n\ngrid_vec::Vector: state vector grid of dimension N\nP::Array{Float64, 2}: transition matrix of dimension N x N\nbounds::Vector: bin bounds of dimension N + 1 #, transtype::Symbol = :importance)\n\n\n\n\n\n","category":"function"},{"location":"Tools/#BASEforHANK.Tools.distrSummaries","page":"Tools","title":"BASEforHANK.Tools.distrSummaries","text":"distrSummaries(\n    distr::AbstractArray,\n    q::Real,\n    x_a_star::AbstractArray,\n    x_n_star::AbstractArray,\n    n_par,\n    net_income::AbstractArray,\n    gross_income::AbstractArray,\n    m_par;\n)\n\nCompute distributional summary statistics for income and wealth, including top-10% wealth, income, and net income shares, Gini indexes for wealth and consumption, and the standard deviation of log labor earnings.\n\nThe function calculates various metrics to summarize the distribution of wealth, consumption, and income based on the provided data. It includes Gini coefficients, shares of wealth and income for the top 10%, and the standard deviation of log labor earnings.\n\nArguments\n\ndistr::AbstractArray: Joint distribution over liquid and illiquid assets and income\nq::Real: Price of illiquid assets\nx_a_star::AbstractArray: Optimal consumption policy with capital adjustment\nx_n_star::AbstractArray: Optimal consumption policy without capital adjustment\nn_par::NumericalParameters\nnet_income::AbstractArray: Vector of (on grid-)incomes (net)\ngross_income::AbstractArray: Vector of (on grid-)incomes (gross)\nm_par::ModelParameters\n\nReturns\n\ndistr_b::AbstractArray: Distribution summary over the first dimension\ndistr_k::AbstractArray: Distribution summary over the second dimension\ndistr_h::AbstractArray: Distribution summary over the third dimension\nTOP10Wshare::Float64: Top 10% wealth share\nTOP10Ishare::Float64: Top 10% gross income share\nTOP10Inetshare::Float64: Top 10% net income share\nginiwealth::Float64: Gini coefficient for wealth\nginiconsumption::Float64: Gini coefficient for consumption\nsdlogy::Float64: Standard deviation of log labor earnings\n\n\n\n\n\n","category":"function"},{"location":"Tools/#BASEforHANK.Tools.myinterpolate3","page":"Tools","title":"BASEforHANK.Tools.myinterpolate3","text":"myinterpolate3(\n    xgrd1::AbstractVector,\n    xgrd2::AbstractVector,\n    xgrd3::AbstractVector,\n    ygrd::AbstractArray,\n    model::AbstractModel,\n    xeval1::AbstractVector,\n    xeval2::AbstractVector,\n    xeval3::AbstractVector\n\n)\n\nTrilinearly project ygrd on (xgrd1, xgrd2, xgrd3) and use it to interpolate values at (xeval1, xeval2, xeval3).\n\nArguments\n\nxgrd1, xgrd2, xgrd3::AbstractVector: Grid points along each of the three dimensions.\nygrd::AbstractArray: Array of function values evaluated at the grid points defined by (xgrd1, xgrd2, xgrd3).\nmodel::AbstractModel: Model object, which can be of type OneAsset, TwoAsset, or CompleteMarkets.\nxeval1, xeval2, xeval3::AbstractVector: Points at which the interpolation is performed along each dimension.\n\nReturns\n\nAn array of interpolated values at the specified evaluation points (xeval1, xeval2, xeval3).\n\nNotes\n\nIt assumes that xgrd1, xgrd2, and xgrd3 are sorted.\n\n\n\n\n\n","category":"function"},{"location":"Tools/#BASEforHANK.Tools.CustomBrent","page":"Tools","title":"BASEforHANK.Tools.CustomBrent","text":"CustomBrent(f::Function, a::Real, b::Real; tol = 1e-14)\n\nFind the root of a function using a customized version of Brent's method. This implementation adapts Brent's method by incorporating initial guesses for value functions and distributions, based on linear interpolations from the previous two iterations.\n\nThe function is designed for cases where the root-finding process needs to account for additional parameters beyond the function's value at the endpoints.\n\nArguments\n\nf::Function: The function for which the root is being found. It should return a tuple, where the first element (f(z)[1]) represents the function value at z, and the subsequent elements represent additional parameters used for interpolation.\na::Real: The lower bound of the interval where the root is located.\nb::Real: The upper bound of the interval where the root is located.\ntol::Real: The tolerance for convergence. The default is 1e-14.\n\nReturns\n\nb::Real: The estimated root of the function.\niter::Int: The number of iterations used to find the root.\nfb::Tuple: The function value at the root, along with any interpolated parameters.\n\nErrors\n\nThrows an error if the function values at a and b have the same sign, indicating no root exists in the specified interval.\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#Post-Estimation-Commands","page":"Post estimation","title":"Post Estimation Commands","text":"","category":"section"},{"location":"PostEstimation/","page":"Post estimation","title":"Post estimation","text":"The PostEstimation submodule provides a set of functions for post-estimation analysis. These functions are designed to work with the output of the model estimation process and provide further insights into the model's behavior. The functions provide plots of impulse responses, variance decompositions and historical decompositions, as well as tables in form of dataframes, where appropriate.","category":"page"},{"location":"PostEstimation/#Usage","page":"Post estimation","title":"Usage","text":"","category":"section"},{"location":"PostEstimation/","page":"Post estimation","title":"Post estimation","text":"You can use these functions by importing the PostEstimation module. Here's an example:","category":"page"},{"location":"PostEstimation/","page":"Post estimation","title":"Post estimation","text":"using .BASEforHANK.PostEstimation\n\n# Now you can call the functions\ncompute_hist_decomp(...)","category":"page"},{"location":"PostEstimation/#Functions","page":"Post estimation","title":"Functions","text":"","category":"section"},{"location":"PostEstimation/#Impulse-Responses","page":"Post estimation","title":"Impulse Responses","text":"","category":"section"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.compute_irfs","page":"Post estimation","title":"BASEforHANK.PostEstimation.compute_irfs","text":"compute_irfs(\n  exovars,\n  gx,\n  hx,\n  XSS,\n  ids;\n  T = 1000,\n  init_val = fill(0.01, length(exovars)),\n  verbose = true\n  distribution = false\n  comp_ids = nothing\n)\n\nComputes impulse response functions (IRFs) for a given set of shocks to exogenous variables.\n\nArguments\n\nexovars::Vector{Int64}: Vector of positional indices of exogenous variables to which shocks are applied.\ngx::Matrix{Float64}: Control matrix (states to controls equations)\nhx::Matrix{Float64}: Transition matrix for states (state transition equations)\nXSS::Vector{Float64}: Steady state values of the model variables.\nids: Indexes of the model variables.\n\nKeyword Arguments\n\nT::Int64: Number of periods for which to compute IRFs.\ninit_val::Vector{Float64}: Initial value of the shock to each exogenous variable, defaults to 0.01 for all shocks.\nverbose::Bool: Print progress to console.\ndistribution::Bool: Compute distributional IRFs, defaults to false.\ncomp_ids: Compression indices for the distribution, as created by prepare_linearization. Needed if distribution is true. Defaults to nothing.\n\nReturns\n\nIRFs, IRFs_lvl: 3D array of (level) IRFs for each exogenous variable, with dimensions:\n1: States and controls\n2: Time periods\n3: Exogenous variables\nIRFs_order: Names of the exogenous variables and their indices in the IRFs array.\nIRFs_dist: Dictionary containing the distributional IRFs in levels, if requested. Dimensions are the same as for IRFs and IRFs_lvl, with the following keys:\n\"Wb\": Marginal value function of liquid assets, nb x T.\n\"Wk\": Marginal value function of illiquid assets, nk x T.\n\"distr_b\": Distribution of liquid assets, nb x T.\n\"distr_k\": Distribution of illiquid assets, nk x T.\n\"distr\": Joint distribution of liquid and illiquid assets, nb x nk x T.\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.plot_irfs","page":"Post estimation","title":"BASEforHANK.PostEstimation.plot_irfs","text":"plot_irfs(\n    shocks_to_plot,\n    vars_to_plot,\n    IRFs_to_plot,\n    IRFs_order,\n    ids;\n    horizon = 40,\n    factor = 100,\n    legend_on_all = false,\n    show_fig = true,\n    save_fig = false,\n    save_fig_indiv = false,\n    path = \"\",\n    suffix = \"\",\n    yscale = \"standard\",\n    style_options = (lw = 2, color = :auto, linestyle = :solid),\n)\n\nPlots impulse response functions (IRFs) for specified shocks and variables, given a set of IRFs as produced by compute_irfs.\n\nArguments\n\nshocks_to_plot::Vector{Tuple{Symbol,String}}: A vector of tuples, where each tuple contains a shock variable (as a Symbol) and its corresponding label (String).\nvars_to_plot::Vector{Tuple{Symbol,String}}: A vector of tuples, each containing a variable to plot (as a Symbol) and its corresponding label (String).\nIRFs_to_plot::Vector{Tuple{Array{Float64,3},String}}: A vector of tuples, where each tuple consists of a 3D array of IRFs (Array{Float64,3}) and a string representing the specification name.\nIRFs_order::Vector{Symbol}: A vector of symbols specifying the order of shocks in the IRF arrays.\nids: A structure mapping variable symbols to their corresponding indices in the IRF arrays, must be identical for all IRFs versions.\n\nKeyword Arguments\n\nhorizon::Int64: The time horizon (number of periods) over which IRFs are plotted. Default is 40.\nfactor::Int64: Scaling factor for the IRFs (default: 100).\nlegend_on_all::Bool: If true, includes the legend on all subplots; otherwise, only the first subplot has a legend. Default is false.\nshow_fig::Bool: If true, displays the plot. Default is true.\nsave_fig::Bool: If true, saves the combined plot as a PDF. Default is false.\nsave_fig_indiv::Bool: If true, saves individual plots for each variable directly inside a shock-specific folder. Default is false.\npath::String: The directory path where the generated plots should be saved. Default is an empty string (no saving).\nsuffix::String: A suffix to append to the saved plot filenames. Default is an empty string.\nyscale::Union{String, Tuple{Number,Number}, Dict{Symbol,Tuple{Number,Number}}}: Y-axis scaling specification. When set to \"common\", computes a common y-axis limit across all subplots from the data; when provided as a tuple, uses it as (ymin, ymax); when provided as a dictionary, applies specified y-axis limits for each variable. Default is \"standard\", which applies default scaling.\nstyle_options::NamedTuple: A named tuple specifying stylistic options for the plots, including line width (lw), color (default: :auto), and linestyle (default: :solid). Default is (lw = 2, color = :auto, linestyle = :solid).\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.plot_irfs_cat","page":"Post estimation","title":"BASEforHANK.PostEstimation.plot_irfs_cat","text":"plot_irfs_cat(\n    shock_categories,\n    vars_to_plot,\n    IRFs_to_plot,\n    IRFs_order,\n    ids;\n    horizon = 40,\n    factor = 100,\n    show_fig = true,\n    save_fig = false,\n    save_fig_indiv = false,\n    path = \"\",\n    suffix = \"\",\n    yscale = \"standard\",\n    style_options = (lw = 2, color = :auto, linestyle = :solid)\n)\n\nPlots impulse response functions (IRFs) for specified shocks and variables, given IRFs as produced by compute_irfs, organized by shock categories.\n\nArguments\n\nshock_categories::Dict{Tuple{String,String},Vector{Symbol}}: A dictionary where each key represents a category of shocks (with a label and a string for saving), and each value is a vector of symbols representing the shocks in that category.\nvars_to_plot::Vector{Tuple{Symbol,String}}: A vector of tuples, each containing a variable to plot (as a Symbol) and its corresponding label (String).\nIRFs_to_plot::Array{Float64,3}: A 3D array of IRFs.\nIRFs_order::Vector{Symbol}: A vector of symbols specifying the order of shocks in the IRF arrays.\nids: A structure mapping variable symbols to their corresponding indices in the IRF arrays, which must be identical for all IRFs versions.\n\nKeyword Arguments\n\nhorizon::Int64: The time horizon (number of periods) over which IRFs are plotted. Default is 40.\nfactor::Int64: Scaling factor for the IRFs (default: 100).\nshow_fig::Bool: If true, displays the plot. Default is true.\nsave_fig::Bool: If true, saves the combined plot as a PDF. Default is false.\nsave_fig_indiv::Bool: If true, saves individual plots for each variable or shock panel directly inside a category-specific folder. Default is false.\npath::String: The directory path where the generated plots should be saved. Default is an empty string (no saving).\nsuffix::String: A suffix to append to the saved plot filenames. Default is an empty string.\nyscale::Union{String, Tuple{Number,Number}, Dict{Symbol,Tuple{Number,Number}}}: Y-axis scaling specification. When set to \"common\", computes a common y-axis limit across all subplots from the data; when provided as a tuple, uses it as (ymin, ymax); when provided as a dictionary, applies specified y-axis limits for each variable. Default is \"standard\", which applies default scaling.\nstyle_options::NamedTuple: A named tuple specifying stylistic options for the plots, including line width (lw), color (default: :auto), and linestyle (default: :solid). Default is (lw = 2, color = :auto, linestyle = :solid).\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.plot_distributional_irfs","page":"Post estimation","title":"BASEforHANK.PostEstimation.plot_distributional_irfs","text":"plot_distributional_irfs(\n    shocks_to_plot,\n    vars_to_plot,\n    IRFs_to_plot,\n    IRFs_order;\n    horizon = 40,\n    factor = 100,\n    legend = false,\n    show_fig = true,\n    save_fig = false,\n    path = \"\",\n    suffix = \"\"\n)\n\nPlots impulse response functions (IRFs) for specified shocks and distributional variables, given a set of IRFs as produced by compute_irfs.\n\nArguments\n\nshocks_to_plot::Vector{Tuple{Symbol,String}}: A vector of tuples, where each tuple contains a shock variable (as a Symbol) and its corresponding label (String).\nvars_to_plot::Vector{Tuple{Symbol,String}}: A vector of tuples, each containing a variable to plot (as a Symbol) and its corresponding label (String).\nIRFs_to_plot::Dict{String,Array{Float64}}: A dictionary of distributional IRFs, where the keys are variable names and the values are arrays of IRFs.\nIRFs_order::Vector{Symbol}: A vector of symbols specifying the order of shocks in the IRF arrays.\n\nKeyword Arguments\n\nhorizon::Int64: The time horizon (number of periods) over which IRFs are plotted. Default is 40.\nfactor::Int64: Scaling factor for the IRFs (default: 100).\nlegend_on_all::Bool: If true, includes the legend on all subplots. Otherwise, only\nshow_fig::Bool: If true, displays the plot (default: true). the first subplot has a legend (default: false).\nsave_fig::Bool: If true, saves the plot as a PDF. Default is false.\npath::String: The directory path where the generated plots should be saved. Default is an empty string (no saving).\nsuffix::String: A suffix to append to the saved plot filenames. Default is an empty string.\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#Variance-Decomposition","page":"Post estimation","title":"Variance Decomposition","text":"","category":"section"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.compute_vardecomp","page":"Post estimation","title":"BASEforHANK.PostEstimation.compute_vardecomp","text":"compute_vardecomp(IRFs)\n\nComputes the variance decomposition of the impulse response functions (IRFs) of a model.\n\nArguments\n\nIRFs::Array{Float64}: 3D array of IRFs for each exogenous variable, with dimensions, returned from compute_irfs:\n1: States and controls\n2: Time periods\n3: Exogenous variables\n\nReturns\n\nVDs: 3D array of variance decompositions for each exogenous variable, with dimensions:\n1: States and controls\n2: Time periods\n3: Exogenous variables\nexovars_names: Names of the exogenous variables.\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.compute_vardecomp_bcfreq","page":"Post estimation","title":"BASEforHANK.PostEstimation.compute_vardecomp_bcfreq","text":"compute_vardecomp_bcfreq(exovars_full, stds, gx, hx; passband = (6, 32), ngrid = 512)\n\nThis function is designed to produce a variance decomposition at business cycle frequencies. It produces a variance decomposition of the linearized solution. It returns the variance decomposition at business cycle frequencies based on Uhlig (2001) and the unconditional variance.\n\nArguments\n\nexovars_full::Vector{Int64}: Vector of positional indices of all exogenous variables to which shocks; note: here, no subset of exogenous variables is allowed.\nstds::Vector{Float64}: Vector of standard deviations of the shocks.\ngx::Matrix{Float64}: Control matrix (states to controls equations)\nhx::Matrix{Float64}: Transition matrix for states (state transition equations)\n\nKeyword Arguments\n\npassband::Tuple{Int64,Int64}: A tuple specifying the horizons associated with the business cycle. Default is (6, 32).\nngrid::Int64: The number of grid points for the computation of the band pass filter. Default is 512.\n\nReturns\n\nVD: Variance decomposition at business cycle frequencies.\nUnconditionalVar: Unconditional variance.\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.plot_vardecomp","page":"Post estimation","title":"BASEforHANK.PostEstimation.plot_vardecomp","text":"plot_vardecomp(\n    vars_to_plot,\n    VDs_to_plot,\n    VDs_order,\n    ids;\n    shock_categories = Dict(),\n    VD_horizons = [4, 16, 100],\n    colorlist = [...],\n    show_fig = true,\n    save_fig = false,\n    path = \"\",\n    suffix = \"\",\n    factor = 100.0,\n)\n\nPlots variance decompositions (VDs) for selected variables across multiple models and forecast horizons, given a set of VDs as produced by compute_vardecomp, potentially organized by shock categories.\n\nArguments\n\nvars_to_plot::Vector{Tuple{Symbol,String}}: A vector of tuples, where each tuple consists of a variable to plot (as a Symbol) and its corresponding label (String).\nVDs_to_plot::Vector{Tuple{Array{Float64,3},String}}: A vector of tuples, where each tuple consists of a 3D array of VDs (Array{Float64,3}) and a string representing the specification name.\nVDs_order::Vector{Symbol}: A vector of symbols specifying the order of shocks in the VD arrays.\nids: A structure mapping variable symbols to their corresponding indices in the VD arrays, must be identical for all VDs versions.\n\nKeyword Arguments\n\nshock_categories::Dict{Tuple{String,String},Vector{Symbol}}: A dictionary where each key represents a category of shocks (with a label and a string for saving), and each value is a vector of symbols representing the shocks in that category.\nVD_horizons::Vector{Int64}: Forecast horizons to consider. Default is [4, 16, 100].\ncolorlist::Vector: A list of colors used to distinguish different shocks in the stacked bar plots. Default includes predefined hex colors and symbols.\nshow_fig::Bool: If true, displays the plot. Default is true.\nsave_fig::Bool: If true, saves the plot as a PDF. Default is false.\npath::String: The directory path where the generated plots should be saved. Default is an empty string (no saving).\nsuffix::String: A suffix to append to the saved plot filenames. Default is an empty string.\nfactor::Float64 = 100.0: Scaling factor for variance decomposition values.\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.plot_vardecomp_bcfreq","page":"Post estimation","title":"BASEforHANK.PostEstimation.plot_vardecomp_bcfreq","text":"plot_vardecomp_bcfreq(\n    vars_to_plot,\n    VDbcs_to_plot,\n    VDbcs_order,\n    ids;\n    shock_categories = Dict(),\n    colorlist = [...],\n    show_fig = true,\n    save_fig = false,\n    path = \"\",\n    suffix = \"\",\n    factor = 100.0,\n)\n\nPlots busincess cycle frequency variance decompositions (VDbcs) for selected variables across multiple models and forecast horizons, given a set of VDbcs as produced by compute_vardecomp_bcfreq, potentially organized by shock categories.\n\nArguments\n\nvars_to_plot::Vector{Tuple{Symbol,String}}: A vector of tuples, where each tuple consists of a variable to plot (as a Symbol) and its corresponding label (String).\nVDbcs_to_plot::Vector{Tuple{Matrix{Float64},String}}: A vector of tuples, where each tuple consists of a matrix of VDbcs (Matrix{Float64}) and a string representing the specification name.\nVDbcs_order::Vector{Symbol}: A vector of symbols specifying the order of shocks in the VDbc arrays.\nids: A structure mapping variable symbols to their corresponding indices in the VD arrays, must be identical for all VDbcs versions.\n\nKeyword Arguments\n\nshock_categories::Dict{Tuple{String,String},Vector{Symbol}}: A dictionary where each key represents a category of shocks (with a label and a string for saving), and each value is a vector of symbols representing the shocks in that category.\ncolorlist::Vector: A list of colors used to distinguish different shocks in the stacked bar plots. Default includes predefined hex colors and symbols.\nshow_fig::Bool: If true, displays the plot. Default is true.\nsave_fig::Bool: If true, saves the plot as a PDF. Default is false.\npath::String: The directory path where the generated plots should be saved. Default is an empty string (no saving).\nsuffix::String: A suffix to append to the saved plot filenames. Default is an empty string.\nfactor::Float64 = 100.0: Scaling factor for variance decomposition values.\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#Historical-Decomposition","page":"Post estimation","title":"Historical Decomposition","text":"","category":"section"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.compute_hist_decomp","page":"Post estimation","title":"BASEforHANK.PostEstimation.compute_hist_decomp","text":"compute_hist_decomp(exovars_full, gx, hx, smoother_output, ids)\n\nComputes the historical decomposition of the model's variables in response to a set of shocks, including the effect of initial conditions and each shock.\n\nArguments\n\nexovars_full::Vector{Int64}: Vector of positional indices of all exogenous variables to which shocks; note: here, no subset of exogenous variables is allowed.\ngx::Matrix{Float64}: Control matrix (states to controls equations)\nhx::Matrix{Float64}: Transition matrix for states (state transition equations)\nsmoother_output: The output from a smoother function.\nids: Indexes of the model variables.\n\nReturns\n\nShockContr::Array{Float64}: A 3D array representing the decomposition of the effects of each shock and the initial condition on states and controls over time. The dimensions are:\n1: States and controls\n2: Time periods\n3: Shocks (including an additional index for the initial condition)\nShockContr_order::Vector{Any}: A vector containing the names or identifiers of the shocks and the initial condition, in the order they appear in the ShockContr array.\n\n\n\n\n\n","category":"function"},{"location":"PostEstimation/#BASEforHANK.PostEstimation.plot_hist_decomp","page":"Post estimation","title":"BASEforHANK.PostEstimation.plot_hist_decomp","text":"plot_hist_decomp(\n    vars_to_plot,\n    HDs_to_plot,\n    HDs_order,\n    ids;\n    shock_categories = Dict(),\n    timeline = collect(1:size(HDs_to_plot, 2)),\n    colorlist = [...],\n    show_fig = true,\n    save_fig = false,\n    path = \"\",\n    suffix = \"\"\n)\n\nPlots historical decompositions (HDs) for specified variables, showing the contribution of different shocks over time, given a set of HDs as produced by compute_hist_decomp, potentially organized by shock categories.\n\nArguments\n\nvars_to_plot::Vector{Tuple{Symbol,String}}: A vector of tuples, where each tuple consists of a variable to plot (as a Symbol) and its corresponding label (String).\nHDs_to_plot::Array{Float64,3}: A 3D array containing historical decompositions, where dimensions correspond to variables, time periods, and shocks.\nHDs_order::Vector{Symbol}: A vector of symbols specifying the order of shocks in the HDs array.\nids: A structure mapping variable symbols to their corresponding indices in the HDs array, ensuring consistency across all plotted variables.\n\nKeyword Arguments\n\nshock_categories::Dict{Tuple{String,String},Vector{Symbol}}: A dictionary where each key represents a category of shocks (with a label and a string for saving), and each value is a vector of symbols representing the shocks in that category.\ntimeline::Vector: A vector specifying the time axis for the plots. Default is a sequence from 1 to the number of time periods in HDs_to_plot.\ncolorlist::Vector: A list of colors used to distinguish different shocks in the stacked bar plots. Default includes predefined hex colors and symbols.\nshow_fig::Bool: If true, displays the plot. Default is true.\nsave_fig::Bool: If true, saves the plot as a PDF. Default is false.\npath::String: The directory path where the generated plots should be saved. Default is an empty string (no saving).\nsuffix::String: A suffix to append to the saved plot filenames. Default is an empty string.\n\n\n\n\n\n","category":"function"},{"location":"HouseholdProblem/#Documentation-of-the-household-problem","page":"Household problem","title":"Documentation of the household problem","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"<span style=\"color:red\">TO DO: Note: this is a preliminary version, needs to be checked carefully and written more clearly.</span>","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"This section documents the household problem that is at the core of the package. Most features are also present in BBL, however, the package extends the model. As a user, given the household problem, you can specify the \"surrounding\" aggregate equations that determine the inputs to the household problem. You can switch off features of the household problem by setting the parameters or variables accordingly.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"The most important assumptions of the household problem are the following:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"GHH preferences with labor supply decision\nTaxes: linear and progressive labor and entrepreneurial income tax, linear value-added tax, linear union-profit tax\nEntrepreneurship as an idiocyncratic state\n2 accounts: liquid and illiquid assets","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"At the end of this section, we provide a list of necessary inputs to the household problem.","category":"page"},{"location":"HouseholdProblem/#Model-setup","page":"Household problem","title":"Model setup","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"There is a continuum of ex-ante identical households of measure one, indexed by i. Households are infinitely lived, have time-separable preferences with time-discount factor beta, and derive felicity from consumption c_it and leisure. They obtain income from supplying labor, n_it, from renting out capital, k_it, and from earning interest on bonds, b_it. What is more, they (potentially) receive entrepreneurial profits, Pi_t^E, and union profits, Pi_t^U. Households pay taxes on labor and profit income as well as a value-added consumption tax.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"The model features household heterogeneity. Households differ in their productivity and in whether they obtain profit income. They face incomplete markets, and capital as an asset is illiquid while bonds are liquid.","category":"page"},{"location":"HouseholdProblem/#Preferences","page":"Household problem","title":"Preferences","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"With respect to leisure and consumption, households have  GHH preferences and maximize the discounted sum of felicity","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    mathbbE_0 sum_t=0^infty beta^t uleftc_it - G(h_itn_it)right\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"The maximization is subject to the budget constraints described further below. The felicity function u exhibits a constant relative risk aversion (CRRA) with risk aversion parameter xi,","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    u(x_it) = fracx_it^1-xi1-xi tagCRRA\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"where x_it = c_it - G(h_itn _it) is household i's composite demand for goods consumption, c_it, and leisure, and G measures the disutility from work. While n_it denotes household i's labor supply, h_it is the household's labor productivity.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"G(h_it n_it)","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"measures the disutility from work. We assume the following form for the disutility from work with gamma0:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    G(h_it n_it) = h_it^1-tau^p fracn_it^1+gamma1+gamma\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"This functional form has several advantages that we will use below. First, the constant elasticity of G with respect to n_it simplifies the expression for the composite consumption good, x_it, in the budget constraint. When the Frisch elasticity of labor supply gamma is constant and the tax schedule has the form specified below, the disutility of labor is always a fraction of labor income and constant across households. Therefore, in both the household's budget constraint and felicity function, only after-tax income enters and neither hours worked nor productivity appear separately. Second, scaling the disutility of labor by h_it^1tau^p ensures a normalization to one in the stationary equilibrium (see BBL p. 1220/1221 for details). In the exponent thereof, tau^p represents the steady state level of progressivity of the tax code, explained below. The functional form simplifies the household problem as h_it drops out from the first-order condition as long as tax progressivity is constant. Then, all households supply the same number of hours. Yet, we allow for tax progressivity to vary over time below. Still, with this functional form, the household problem is more tractable.","category":"page"},{"location":"HouseholdProblem/#Income-taxation","page":"Household problem","title":"Income taxation","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"We assume a progressive labor and entrepreneurial income tax schedule as in BBL (with one modification explained below) given by","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    f_tau(x) = (1-tau^l_t) x^1-tau^p_t  (barY^g_t)^tau^p_t tagTax func\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Here (and this is the modification relative to BBL), the average level of gross income across households, barY^g_t, influences individual taxing and thus net income, y^n_it. tau^l_t and tau^p_t determine the level and progressivity of the tax code.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"The tax level shifter (barY^g_t)^tau^p_t ensures that in the corresponding representative agent economy, tax income (holding behavior constant) is independent of progressivity. To see this, plug in the average gross income, barY^g_t, which corresponds to the gross income of a representative agent, as tax basis x. This gives f_tau(barY^g_t)= (1-tau^l_t)barY^g_t, so that in the corresponding representative agent economy, the tax progressivity vanishes. In the code, this tax level shifter can be easily switched off.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Income related to union profits, Pi^U_t, is taxed at a rate bar tau_t that is independent of the recipient's labor income.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Asset income is not taxed.","category":"page"},{"location":"HouseholdProblem/#Idiosyncratic-productivity","page":"Household problem","title":"Idiosyncratic productivity","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"The household sector is subdivided into two types of agents: workers and entrepreneurs. The transition between both types is stochastic. On top, workers face idiosyncratic labor productivity risk. Both, workers and entrepreneurs, rent out physical capital, but only workers supply labor. Entrepreneurs do not work, but earn entrepreneurial profits, Pi_t^E. Profits of unions, Pi_t^U, are equally distributed across workers. All households self-insure against the income risks they face by saving in a liquid asset (bonds) and a less liquid asset (capital). Trading these illiquid assets is subject to random participation in the capital market.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"We assume that productivity evolves according to a log-AR(1) process and a fixed probability of transition between the worker and the entrepreneur state:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"tildeh_it =\nbegincases\nexpleft(rho_h log tildeh_it-1 + epsilon^h_itright)  textwith probability  1-zeta text if  h_it-1 neq 0 \n1  textwith probability  iota text if  h_it-1 = 0 \n0  textelse\nendcases","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"with individual productivity h_it= fractildeh_ittildeH_it such that tilde h_it is scaled by its cross-sectional average, tildeH_it = int tilde h_it di, to make  sure that average worker productivity is constant. The shocks epsilon^h_it to productivity tildeh_it are normally distributed with variance bar sigma^2_ht.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"With probability zeta households become entrepreneurs (h=0). With probability iota an entrepreneur returns to the labor force with median productivity. Besides their labor income, workers receive a share in union rents, Pi^U_t, which are distributed lump sum, leading to labor-income compression. For tractability, we assume union profits to be taxed at a rate barτ_t independent of the recipient's labor income.","category":"page"},{"location":"HouseholdProblem/#Budget-constraint","page":"Household problem","title":"Budget constraint","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"A household's net labor income, y^n_it, is given by","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    y^n_it = f_tau (w^H_t h_it n_it)\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"where w^H_t is the real wage rate that household receive, h_it is the (scaled) productivity of the household, and n_it is the amount of labor supplied.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Given incomes, households optimize intertemporally subject to their budget constraint","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n(1 + tau^c_t) c_it + b_it+1 + q_t k_it+1 = RR^i_t b_it + (q_t + r^K_t)k_it + y^n_it + 1h_it neq 0(1 - bar tau_t) Pi^U_t + 1h_it = 0 f_tau(Pi^E_t)\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"where Pi^U_t is union profits taxed at the average tax rate of labor income bar tau_t, Pi^E_t is profit payouts to entrepreneurs, b_it is real liquid assets, k_it is the amount of illiquid assets, q_t is the price of these assets, r^K_t is their dividend, and RR^i_t is the gross real interest rate on liquid assets, which depends on whether the household (thus, the dependence on i) is a borrower or lender.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"All households that do not participate in the capital market (k_it+1=k_it) still obtain dividends and can adjust their liquid asset holdings. Depreciated capital has to be replaced for maintenance, such that the dividend, r^K_t, is the net return on capital. Holdings of bonds have to be above an exogenous debt limit underlineB and holdings of capital have to be non-negative, that is","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"k_it+1 geq 0 quad b_it+1 geq underlineB","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Recall, f_tau(Pi_t^E) is the progressive tax function defined above, applied to profit payouts to entrepreneurs. In contrast, merely the average tax rate bar tau_t (further details below) is applied to the union's profits.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Additionally, consumption is taxed at a rate tau^c_t, i.e. a VAT tax.","category":"page"},{"location":"HouseholdProblem/#Side-note:-computation-of-the-budget-constraint-elements-in-the-code","page":"Household problem","title":"Side note: computation of the budget constraint elements in the code","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"In the code, the elements of the budget constraint that are necessary to compute the household problem are computed by the incomes() function. Based on the parameters and aggregate variables, the function computes (at least) the following elements:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Net labor and union income for workers, adjusted for the composite good / net entrepreneurial profits for entrepreneurs, that is y^n_it + 1h_it neq 0(1 - bar tau_t) Pi^U_t + 1h_it = 0 f_tau(Pi^E_t) plus the adjustment for the composite good derived below.\nRental income from illiquid assets, that is r^K_t k_it.\nLiquid asset income, that is RR^i_t b_it.\nLiquidation income from illiquid assets, that is q_t k_it+1.","category":"page"},{"location":"HouseholdProblem/#Asset-market","page":"Household problem","title":"Asset market","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Households make their savings and portfolio choice between liquid bonds and illiquid capital in light of a capital market friction that renders capital illiquid because participation in the capital market is random and i.i.d. in the sense that only a fraction lambda of households are selected to be able to adjust their capital holdings in a given period.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"The ex-post real return on the liquid asset, RR^i_t, is","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    RR^i_t =\nbegincases\n    RR^L_t  text if  b_it geq 0 \n    RR^D_t  text else tagReturn liquid\nendcases\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Here, RR^L_t is the real lending rate and RR^D_t is the real borrowing rate. There is potentially a wedge between the two rates.","category":"page"},{"location":"HouseholdProblem/#Underlying-decision-problem","page":"Household problem","title":"Underlying decision problem","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Households face the following decision problem:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    max_leftc_itn_itb_it+1k_it+1right mathbbE_0 sum_t=0^infty beta^t uleftc_it - G(h_itn_it)right\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"subject to the budget constraint and both short-selling constraints.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Moreover, as stated above, the household might not be able to adjust its capital holdings in a given period. Expectations are thus formed over income states and the stochastic participation on the capital market. In periods, where the household cannot adjust, it faces the same problem except for the additional condition k_it+1 = k_it.","category":"page"},{"location":"HouseholdProblem/#Labor-supply-decision","page":"Household problem","title":"Labor supply decision","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Consider the following Lagrangian of the household problem (ignoring the asset choice here, since it is not relevant for the labor supply decision):","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\nmathcalL = E_0 sum_t=0^infty beta^t Bigg( u(c_it - G(h_it n_it)) + lambda_it left RR^i_t b_it + (q_t + r^K_t) k_it + y^n_it + 1h_it neq 0(1 - bar tau_t)Pi^U_t + 1h_it = 0 f_tau(Pi^E_t) - (1 + tau^c_t) c_it\n - b_it+1 - q_t k_it+1right + dots Bigg)\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Remember, y^n_it denotes the household's net labor income.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Combining the first-order conditions with respect to labor n_it and consumption c_it yields:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\nfracpartial G(h_it n_it)partial n_it = frac1(1 + tau^c_t)fracpartial y^n_itpartial n_it = frac1(1 + tau^c_t) (1- tau^p) fracy^n_itn_it tagFOC labor\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Together with partial G(h_it n_it) partial n_it = (1+gamma)G(h_it n_it)n_it (see above), we can express the composite consumption good, x_it, as","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\nx_it = c_it - G(h_it n_it) = c_it - frac11+gamma frac1-tau^p_t1+tau^c_t  y^n_it tagCons comp labor\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"We allow for the parameter tau^p_t governing the progressivity of the tax schedule to vary over time. In this case, as explained in footnote 12 of BBL, whenever tax progressivity does not coincide with its steady state level tau^p, individual hours worked differ across agents. The labor supply under time-varying tax progressivity can be derived from eq. (FOC labor) and is similar to BBL equation (19a). It is given by:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"n_it = left frac(1 - tau^p_t)(1 - tau^l_t)(1+tau^c_t)  (barY^g_t)^tau^p_t right^frac1gamma + tau^p_t\n(w^H_t)^frac1 - tau^p_tgamma + tau^p_t\nh_it^fractau^p - tau^p_tgamma + tau^p_t","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"On aggregate, this results in total effective hours (compare equation (19b) of BBL):","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"N_t = int n_ith_it  di = left frac(1 - tau^p_t)(1 - tau^l_t)(1+tau^c_t)  (barY^g_t)^tau^p_t right^frac1gamma + tau^p_t\n(w^H_t)^frac1 - tau^p_tgamma + tau^p_t underbraceint h_it^fracgamma + tau^pgamma + tau^p_t  di_= H^p_t tagTotal hours","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Individual hours worked, n_it, can thus be written as a function of total effective hours N_t: n_it  = N_tH^p_t  h_it^(tau^p - tau^p_t)(gamma + tau^p_t).","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Given the labor decision, net income can be calculated.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"We plug the optimal supply of hours, n_it, into the equation for net income, y^n_it, which is then (compared to equation (22) in BBL):","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\ny^n_it = (1 - tau^l_t)(w^H_t h_it n_it)^1 - tau^p_t (barY^g_t)^tau^p_t = (1 - tau^l_t)^frac1+gammagamma + tau^p_t\n (1 - tau^p_t) ^ frac1-tau^p_tgamma + tau^p_t\n (1 + tau^c_t) ^ -frac1-tau^p_tgamma + tau^p_t\n w_t ^ frac(1 + gamma)(1 - tau^p_t)gamma + tau^p_t\n h_it ^ frac(gamma + tau^p)(1-tau^p_t)gamma + tau^p_t\n (barY^g_t)^fractau^p_t (1+gamma)gamma + tau^p_t\n endalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Plugging individual hours as a function of total effective hours into gross income, results in","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"y^g_it = w^H_t h_it n_it = w^H_t  fracN_tH^p_t  h_it^fracgamma + tau^pgamma + tau^p_t tagGross income","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Finally, consumption in the budget constraint can be replaced with the composite consumption good x_it:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n(1 + tau^c_t) x_it + b_it+1 + q_t k_it+1 = RR^i_t b_it + (q_t + r^K_t)k_it + left(1 - frac1-tau^p_t1+gammaright) y^n_it + 1h_it neq 0(1 - bar tau_t) Pi^U_t + 1h_it = 0 f_tau(Pi^E_t) tagBC with x\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"where left(1-frac1-tau^p_t1+gammaright) simplifies to left(fractau^p_t + gamma1+gammaright). This GHH factor is used in the code to transform net labor income, y^n_it, into the composite consumption good units. Here, we have to take the VAT additionally into account.","category":"page"},{"location":"HouseholdProblem/#Portfolio-choice","page":"Household problem","title":"Portfolio choice","text":"","category":"section"},{"location":"HouseholdProblem/#Description-of-the-dynamic-problem","page":"Household problem","title":"Description of the dynamic problem","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"In the following, unlike in other sections of the documentation, we will adopt recursive notation (where a prime, ', denotes next period's value) for clarity. Policy functions are denoted with a star, *, and subscripts indicate whether the policy pertains to the adjustment case, a, or the non-adjustment case, n. For example, x^*_a represents the policy function for the consumption-leisure bundle in the adjustment case, while x^*_n represents it in the non-adjustment case. For notational brevity, we refer to the consumption-leisure composite simply as consumption throughout.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Since a household's saving decision will be some non-linear function of that household's wealth and productivity, inflation and all other prices will be functions of the joint distribution, Theta_t, of (bkh) in t. This makes Theta_t a state variable of the household's planning problem. It evolves as a result of the economy's reaction to aggregate shocks according to:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    Theta_t+1(bkh) =lambda int _b=b_at^*(bkh)k=k_t^*(bkh)Pi(hh)dTheta_t(bkh)\n    + (1-lambda) int_b=b_nt^*(bkh)k=kPi(hh)dTheta_t(bkh) \nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"where Pi(cdot) is the transition probability for h and b_ant^* and k_t^* are the time-t optimal policies.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"For simplicity, we summarize all effects of aggregate state variables, including the distribution of wealth and income, by writing the dynamic planning problem with time-dependent continuation values.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"This leaves us with two Bellman equations, that characterize the household's problem: V^a_t for the case where the household adjusts its capital holdings and V^n_t for the case in which it does not adjust. A third function defines the expected continuation value, mathbbW_t, over both,","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\nV^a_t(bkh) = max_b_ak  ux(bb_akkh)+ betamathbbE_t mathbbW_t+1(b_akh)  nonumber\nV^n_t(bkh) = max_b_n  ux(bb_nkkh) + beta mathbbE_tmathbbW_t+1(b_nkh)  \nmathbbW_t+1(bkh) = lambda V_t+1^a(bkh) +(1-lambda)V^n_t+1(bkh)  nonumber\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Expectations about the continuation value are taken with respect to all stochastic processes (i.e. with respect to idiosyncratic and aggregate variables) conditional on the current states.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"The budget sets for the adjustment case Gamma_a and the non-adjustment case Gamma_n are given by","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    Gamma_a(bkh) = Bigg k geq 0 b geq underlineB mid q (k - k) + b leq left(fractau^p + gamma1+gammaright) y^n + RR(b) b + r^K k \n     + 1h neq 0(1- tau)Pi^U + 1h = 0 f_tau(Pi^E) Bigg \n    Gamma_n(bkh) = Biggb geq underlineB mid  bleq left(fractau^p + gamma1+gammaright) y^n + RR(b) b + r^K k \n     + 1h_it neq 0(1- tau)Pi^U + 1h_it = 0 f_tau(Pi^E) Bigg\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Moreover, the consumption leisure composite x is","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    x(bbkkh) = frac11+tau^c Bigg left(fractau^p + gamma1+gammaright) y^n + RR(b) b + r^K k \n     + 1h neq 0(1- tau)Pi^U + 1h = 0 f_tau(Pi^E) - b - q (k - k) Bigg\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"As Bayer, Luetticke, Pham-Dao and Tjaden (2019) show in the online Appendix B, the Bellman equation fullfills Blackwell's sufficient condition for a contraction on the set of bounded, continuous and weakly concave functions, such that we can expect to find a solution to the problem.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"When solving the problem, we do not use the value functions. Instead, we rely on the first-order conditions that characterize the optimal household behavior to solve for policy functions. The next section develops the equations that are necessary for an iterative algorithm that solves for optimal policies, before we describe the exact algorithm thereafter.","category":"page"},{"location":"HouseholdProblem/#Euler-Equations","page":"Household problem","title":"Euler Equations","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Denote the optimal policies for consumption, for liquid asset holdings and illiquid asset holdings as x_a^*, b_a^*, k_a^*, x_n^*, and b_n^*, respectively. The first-order conditions (FOCs) for a solution in the adjustment case and the non-adjustment case read:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    k^*_a quad  fracpartial u(x^*_a)partial x geq (1 + tau^c) q^-1 beta  mathbb E  fracpartial mathbb W (b^*_a k^*_a h)partial k tagFOC1 \n    b^*_a quad fracpartial u(x^*_a)partial x geq (1 + tau^c) beta  mathbb E  fracpartial mathbb W (b^*_a k^*_a h)partial b tagFOC2 \n    b^*_n quad fracpartial u(x^*_n)partial x geq (1 + tau^c) beta  mathbb E  fracpartial mathbb W (b^*_n k h)partial b tagFOC3\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"Note the subtle difference between (FOC2) and (FOC3), which lies in the different illiquid assets stocks k^*_a vs. k entering as arguments on the right-hand-side. The difference arises from the asset market friction that only allows a fraction of households to adjust their illiquid asset holding. The continuation values (CVs) are defined as:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    fracpartial mathbb Wpartial k (b k h) =  lambda fracpartial V_a(b k h)partial k + (1 - lambda)fracpartial V_n(b k h)partial k tagCV1 \n    fracpartial mathbb Wpartial b (b k h) = lambda fracpartial V_a(b k h)partial b + (1 - lambda)fracpartial V_n(b k h)partial b tagCV2\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"To characterize continuation values, we calculate the derivatives of the value functions for the adjustment and non-adjustment cases with respect to liquid and illiquid assets. Using the Envelope conditions (ECs), we obtain:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    fracpartial V_apartial k(b k h) = fracpartial ux^*_a(b k h)partial x left( fracq + r^K1 + tau^c right) tagEC1 \n    fracpartial V_apartial b(b k h) = fracpartial ux^*_a(b k h)partial x RR(b) frac11 + tau^c tagEC2 \n    fracpartial V_npartial b(b k h) = fracpartial ux^*_n(b k h)partial x RR(b) frac11 + tau^c tagEC3 \n    fracpartial V_npartial k(b k h) = fracpartial ux^*_n(b k h)partial x left(fracr^K1 + tau^cright) \n     quad + beta  mathbb E left lambda fracpartial V_ab^*_n(b k h) k hpartial k + (1 - lambda)fracpartial V_nb^*_n(b k h) k hpartial kright \n    = fracpartial ux^*_n(b k h)partial x left(fracr^K1 + tau^cright) + beta  mathbbE fracpartial mathbb W b^*_n(b k h) k hpartial k tagEC4\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"such that the marginal value of the illiquid asset in the non-adjustment case is defined recursively.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"By substituting the Envelope conditions (ECs) into the continuation values (CVs) and the composite expression into the first-order conditions (FOCs), we derive the Euler equations (EEs) that characterize optimal household behavior. Using a slightly simplified notation, these are given by the following equations:","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"beginalign*\n    fracpartial ux_a^*(b k h)partial x geq q^-1 beta  mathbb E (1 + tau^c) left lambda  fracpartial ux^*_a(b^*_a k^*_a h)partial x left( fracq+r^K1 + tau^c right) + (1-lambda)fracpartial V_npartial k (b_a^*k^*_a h) right tagEE1 \n    fracpartial ux_a^*(bk h)partial x geq beta  mathbb E RR(b^*) left( frac1 + tau^c1 + tau^c right) left lambda  fracpartial ux^*_a(b^*_ak^*_a h)partial x + (1-lambda)fracpartial ux^*_n(b_a^*k^*_a h)partial xright tagEE2 \n    fracpartial ux_n^*(bk h)partial x  geq beta  mathbb E RR(b^*) left( frac1 + tau^c1 + tau^c right) left lambda  fracpartial ux_a^*(b_n^*k h)partial x + (1-lambda)fracpartial ux_n^*(b_n^*k h)partial xright tagEE3\nendalign*","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"In the non-adjustment case, the intuition behind the Euler equation is standard: the household equates the marginal loss of utility today from saving an additional unit with the expected marginal utility gain from saving that unit.","category":"page"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"In the adjustment case, the household also faces a portfolio problem. Intuitively, it selects the optimal combination of the liquid and illiquid assets by comparing the expected one-period return difference between the two assets, mathbb E left( RR(b^*) - fracr^K + qq right), weighted by the probability-adjusted marginal utilities. (We abstract from the non-differentiability at b=0.) After having decided the optimal portfolio combination, the household then faces the identical tradeoff between consumption today and consumption tomorrow as in the non-adjustment case.","category":"page"},{"location":"HouseholdProblem/#Solving-the-dynamic-planning-problem","page":"Household problem","title":"Solving the dynamic planning problem","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"The endogenous grid algorithm (EGM) is used to solve the dynamic household problem with two assets. The first-order conditions and Euler equations, which were derived above, form the foundation of the iterative algorithm. The document Computational Notes.md provides a step-by-step explanation of the computational procedure implemented in the code.","category":"page"},{"location":"HouseholdProblem/#Inputs-to-the-household-problem","page":"Household problem","title":"Inputs to the household problem","text":"","category":"section"},{"location":"HouseholdProblem/#Inputs:-Parameters","page":"Household problem","title":"Inputs: Parameters","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"time-discount factor, beta\nrisk aversion parameter, xi\nFrisch elasticity of labor supply, gamma\nsteady-state progressivity of the tax code, tau^p\npersistence of the productivity shock, rho_h\nvariance of the productivity shock, bar sigma^2_h\nprobability of becoming an entrepreneur, zeta\nprobability of returning to the labor force, iota\ndebt limit, underlineB\nprobability of adjusting illiquid assets, lambda","category":"page"},{"location":"HouseholdProblem/#Inputs:-Aggregate-variables","page":"Household problem","title":"Inputs: Aggregate variables","text":"","category":"section"},{"location":"HouseholdProblem/","page":"Household problem","title":"Household problem","text":"real wage rate that households receive, w^H_t\nlevel of the tax code, see tax function (Tax func), tau^l_t\nprogressivity of the tax code, see tax function (Tax func), tau^p_t\naverage gross income across households, see tax function (Tax func), barY^g_t\nvariance of the productivity shock, bar sigma^2_ht\nunion profits, Pi^U_t\nentrepreneurial profits, Pi^E_t\ntax rate on union profits, bar tau_t\nVAT tax rate, tau^c_t\nprice of illiquid assets, q_t\nreal dividend on illiquid assets, r^K_t\nreal lending rate, RR^L_t\nreal borrowing rate, RR^D_t\ncross-sectional average of productivity before scaling, tildeH_t\ncross-sectional average of productivity, weighted by tax progressivity factor, H^p_t\ntotal effective hours, N_t","category":"page"},{"location":"Parsing/#Parsing","page":"Parser","title":"Parsing","text":"","category":"section"},{"location":"Parsing/","page":"Parser","title":"Parser","text":"The Parsing submodule provides macros used for automatic code generation, structs, indexes, etc. These map, e.g., deviations from steady state of aggregate variables to equations lines in the non-linear difference equation that describe the economy.","category":"page"},{"location":"Parsing/#Collect-variables:-macros","page":"Parser","title":"Collect variables: macros","text":"","category":"section"},{"location":"Parsing/#BASEforHANK.Parsing.@writeXSS","page":"Parser","title":"BASEforHANK.Parsing.@writeXSS","text":"@writeXSS()\n\nWrite all single steady state variables into vectors XSS / XSSaggr.\n\nRequires\n\n(module) globals state_names, control_names, aggr_names\n\n\n\n\n\n","category":"macro"},{"location":"Parsing/#BASEforHANK.Parsing.@make_fn","page":"Parser","title":"BASEforHANK.Parsing.@make_fn","text":"@make_fn(fn_name)\n\nCreate function fn_name that returns an instance of IndexStruct (created by @make_struct), mapping states and controls to indexes inferred from numerical parameters and compression indexes.\n\nRequires\n\n(module) global state_names, control_names\n\n\n\n\n\n","category":"macro"},{"location":"Parsing/#BASEforHANK.Parsing.@make_fnaggr","page":"Parser","title":"BASEforHANK.Parsing.@make_fnaggr","text":"@make_fnaggr(fn_name)\n\nCreate function fn_name that returns an instance of IndexStructAggr (created by @make_struct_aggr), mapping aggregate states and controls to values 1 to length(aggr_names) (both steady state and deviation from it).\n\nRequires\n\n(module) global aggr_names\n\n\n\n\n\n","category":"macro"},{"location":"Parsing/#BASEforHANK.Parsing.@make_struct","page":"Parser","title":"BASEforHANK.Parsing.@make_struct","text":"@make_struct(struct_name)\n\nMake struct_name with two fields for every variable name in s_names (state variables) and c_names (control variables), together with fields for distribution-states and marginal value function-controls.\n\nRequires\n\n(module) globals state_names, control_names\n\n\n\n\n\n","category":"macro"},{"location":"Parsing/#BASEforHANK.Parsing.@make_struct_aggr","page":"Parser","title":"BASEforHANK.Parsing.@make_struct_aggr","text":"@make_struct_aggr(struct_name)\n\nMake struct_name with two fields for every variable name in aggr_names (for steady state value and for deviation from it).\n\nRequires\n\n(module) global aggr_names\n\n\n\n\n\n","category":"macro"},{"location":"Parsing/#BASEforHANK.Parsing.@generate_equations","page":"Parser","title":"BASEforHANK.Parsing.@generate_equations","text":"@generate_equations()\n\nWrite out the expansions around steady state for all variables in aggr_names, i.e. generate code that reads aggregate states/controls from steady state deviations.\n\nEquations take the form of (with variable r as example):\n\nr       = exp.(XSS[indexes.rSS] .+ X[indexes.r])\nrPrime  = exp.(XSS[indexes.rSS] .+ XPrime[indexes.r])\n\nRequires\n\n(module) global aggr_names\n\n\n\n\n\n","category":"macro"},{"location":"Computational Notes/#Computational-Notes","page":"Computational Notes","title":"Computational Notes","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"This document provides detailed explanations of the computations executed in the code. The topics covered include:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The Endogenous Grid Point Method for solving the household problem.\nAggregation of the household side using non-stochastic simulations.","category":"page"},{"location":"Computational Notes/#Algorithm-of-the-Endogenous-Grid-Method","page":"Computational Notes","title":"Algorithm of the Endogenous Grid Method","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We use the Endogenous Grid Method to solve for optimal policies, given marginal continuation values EWb, EWk, today's prices and income. Having established the required equations in HouseholdProblem, we can now illustrate the algorithm in detail. We use a version of the Hintermaier and Koeniger (2010) extension of the endogenous grid method, originally developed by Carroll (2006). Intuitively, instead of determining asset and consumption choices simultaneously, we fix asset policies on predefined (exogenous) grid points for the future. We then identify the consumption policy associated with these asset policies and calculate the required resources, known as endogenous grid points, for the household to achieve these policies. Finally, we interpolate the derived policy functions from the endogenous grid points back onto the exogenous grids of the discretized state space.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The algorithm works iteratively until convergence of continuation values as follows:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Guess initial marginal continuation values (CV1) and (CV2) (in fcn_kdiff.jl).\nCompute the expected values of the continuation values (CV1) and (CV2) (in fcn_ksupply.jl).\nUpdate the optimal policies given the expected marginal continuation values using the FOCs (in EGM_policyupdate.jl)\na. Find optimal liquid asset policy in the non-adjustment case.\nb. Find optimal portfolio combination in the adjustment case.\nc. Standard backward EGM step given the optimal portfolio choice.\nUpdate the continuation values (CV1) and (CV2) using the Envelope conditions (EC1) - (EC4) (in updateW.jl).\nCheck convergence of the (inverse) continuation values (in fcn_ksupply.jl). If they have converged, stop, otherwise repeat steps 1-3.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Below, we will illustrate the individual steps of the computational procedure implemented in the code. We will use the expressions vec b, vec k, and vec h for the exogenously given vectors over which we discretize the continuous state space. Let n_b, n_k, and n_h denote the sizes of the grids vec b, vec k, and vec h, respectively. For the sake of illustrating the algorithm, we use the superscript m as a placeholder for the current iteration.","category":"page"},{"location":"Computational Notes/#0.-Initial-guesses-for-the-marginal-values","page":"Computational Notes","title":"0. Initial guesses for the marginal values","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"To run the algorithm, we require guesses for the marginal values. These guesses are specified in fcn_kdiff.jl. We calculate them based on a very simple initial guess for the policy function of consumption x^textguess","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\nx^textguess = y(h) + RR(b) b times 1b  0 + r^K k  times 1k  0\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"where we have summarized all different labor income types in the variable y(h) = left(fractau^p + gamma1+gammaright) y^n + 1h_it neq 0(1- tau)Pi^U + 1h_it = 0 f_tau(Pi^E). For the calculation of the guess, we have used the exogenous grid values. The consumption guess x^textguess serves as an upper bound for the policy function, assuming the household consumes the entire cash-at-hand in the non-adjustment case. We use this guess for the policy function in both the adjustment and non-adjustment cases.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Based on this guess, we calculate the guesses for the continuation values","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\nfracpartial mathbb W^0partial k (b k h) = (1 + r^k + lambda) fracpartial u(x^guess)partial x \nfracpartial mathbb W^0partial b (b k h) = RR(b) fracpartial u(x^guess)partial x \nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"where the superscripts at fracpartial mathbb W^0partial k and fracpartial mathbb W^0partial b denote the iteration of the marginal value, with 0 indicating the initial guess. Note that this is not in line with the equations (CV1) and (CV2), but it is an assumption we make for the initial guesses of the marginal values.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"These guesses are then used in fcn_ksupply.jl as input in the function Ksupply. The latter function hosts the actual calculation of the household policy functions within a loop. Steps 1-4 below illustrate the individual steps to find the policy functions.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"In line with the notation above, we will use superscripts on the continuation values (CV1) and (CV2) to indicate the iteration in which these were computed.","category":"page"},{"location":"Computational Notes/#1.-Compute-the-expected-value-of-the-continuation-values","page":"Computational Notes","title":"1. Compute the expected value of the continuation values","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Based on the continuation values from the last iteration m-1, fracpartial mathbb W^m-1partial k and fracpartial mathbb W^m-1partial b, we compute the expected continuation values","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\nmathbb E fracpartial mathbb W^m-1partial k (b k h) equiv mathbb E left fracpartial mathbb W^m-1partial k (b k h)  h right = sum_h Pi(h h) fracpartial mathbb W^m-1partial k (b k h) tagECV1 \nmathbb E fracpartial mathbb W^m-1partial b (b k h) equiv mathbb E left fracpartial mathbb W^m-1partial b (b k h)  h right = sum_h Pi(h h) fracpartial mathbb W^m-1partial b (b k h) tagECV2\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Concretely, we use the transition matrix Pi(h h) to weight future continuation values by the probability to transit into the future productivity state h, given the productivity state h today and sum over all potential realizations of future productivity states h. Note that by taking expectations over future productivity levels, h, the expected continuation value becomes a function of todays productivity state h.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The code executes the calculation of this continuation value using BLAS.gemm!. This is Julia's most efficient double precision matrix multiplication.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"BLAS.gemm!(\n    'N',\n    'T',\n    1.0,\n    reshape(Wk, (nb .* nk, nh)),\n    n_par.Π,\n    0.0,\n    reshape(EWk, (nb .* nk, nh)),\n)\nEWk .= reshape(EWk, (nb, nk, nh))","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Here, Wk denotes fracpartial mathbb W^m-1partial k (b k h) and EWk denotes mathbb E fracpartial mathbb W^m-1partial k (b k h).","category":"page"},{"location":"Computational Notes/#2.-Update-the-optimal-policy-functions","page":"Computational Notes","title":"2. Update the optimal policy functions","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"With expected continuation values at hand, we would like to use the FOCs (FOC1), (FOC2), and (FOC3) to obtain updates for the policy functions. The update of the policy functions is done in EGM_policyupdate.jl in the function EGM_policyupdate!. The calculation is done in several steps that have several substeps themselves which reflect that the household is either able to trade illiquid assets (adjustment case) or not (non-adjustment case):","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"a) Find optimal liquid asset policy in the non-adjustment case.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"b) Find optimal portfolio combination in the adjustment case.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"c) Standard backward EGM step given the optimal portfolio choice.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We will illustrate each of these steps in detail below.","category":"page"},{"location":"Computational Notes/#a)-Find-optimal-liquid-asset-policy-in-the-non-adjustment-case","page":"Computational Notes","title":"a) Find optimal liquid asset policy in the non-adjustment case","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"In the non-adjustment case, household face a consumption-saving decision with idiosyncratic risk over the income states in the next period. The core equation is (FOC3), which we repeat here for convenience:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"fracpartial u(x^*_n)partial x geq (1 + tau^c) beta  mathbb E  fracpartial W^m-1partial b (b^*_n k h) equiv EMU (b^*_n k h) tagFOC3","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Here, we have defined EMU for reference below. The relevant substeps to find updates for the policy functions are","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"i) Calculate the right-hand-side of (FOC3).","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"ii) Apply the inverse of the marginal utility function to the right-hand-side of (FOC3).","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"iii) Find the endogenous grid points associated with the policy choice.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"iv) Interpolate back from the endogenous grid onto the exogenous grid.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"v) Ensure that the borrowing constraint is respected.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We will use the right-hand-side of equation (FOC3), but instead of defining it on the grid (b^*_n k h), we will evaluate it on the exogenously fixed grid (b k h). This means we evaluate the continuation value at fixed asset choices on the exogenous grid b for the next period and calculate the optimal corresponding consumption choice for today. Given the fixed savings choice and the corresponding optimal consumption, we can then calculate the endogenous grid points, which are the resources associated with these plans. Using these endogenous grid points, we can interpolate our policy functions from the endogenous grid to the exogenous grid. Each of these steps is explained on the following.","category":"page"},{"location":"Computational Notes/#i)-Calculate-the-right-hand-side-of-(FOC3),-EMU","page":"Computational Notes","title":"i) Calculate the right-hand-side of (FOC3), EMU","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"From the last iteration of the endogenous grid point method, we obtained the continuation value (CV2), EWb, which enters the right-hand-side of (FOC3). Since the right-hand-side expression will be used in several places of the algorithm, we calculate it as one expression and save it to a variable denoted EMU:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"EMU .= EWb .* β .* (1.0 .+ τc)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"EWb denotes the expected marginal utility of the liquid asset that we computed in step 1 above and enters the function EGM_policyupdate as an argument. τc is the consumption tax rate today, which affects the optimal consumption schedule by altering the intertemporal price of consumption. As a result, we can express (FOC3) as","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"fracpartial u(x^*_n)partial x geq EMU (b^*_n k h)","category":"page"},{"location":"Computational Notes/#ii)-Apply-the-inverse-of-the-marginal-utility-function-to-the-right-hand-side-of-(FOC3)","page":"Computational Notes","title":"ii) Apply the inverse of the marginal utility function to the right-hand-side of (FOC3)","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Assume for now that this holds with equality, and let tilde b denote the so-called endogenous grid of the liquid asset today. The endogenous grid is the level of the liquid asset today that makes the household choose liquid assets b tomorrow (which we will fix to be on the exogenous grid vec b). With the endogenous grid, we can apply the inverse of the marginal utility","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"x^*_n(tilde b k h) =(u)^-1(EMU (b k h))","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"which denotes the consumption policy function today at the endogenous gridpoints tilde b. Conditional on the household choosing b in the next period and having illiquid asset state k (recall, due to the non-adjustment, k = k), and productivty state h, the consumption policy x^*_n(tilde b k h) denotes the optimal choice of consumption given liquid assets tilde b today. In the code the inversion is handled by","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"invmutil!(x_tilde_n, EMU, m_par)","category":"page"},{"location":"Computational Notes/#iii)-Find-the-endogenous-grid-points-associated-with-the-policy-choice","page":"Computational Notes","title":"iii) Find the endogenous grid points associated with the policy choice","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"In the former step, we obtained the policy function defined on the endogenous grid tilde b, but haven't explicitly calculated the values of the endogenous grid tilde b that are consistent with assets tomorrow and the respective policy optimal choice of consumption today. We cannot use the policy function on the endogenous grid, but require it on the exogenous grid of the liquid asset, b. Therefore, we will interpolate the policy function from the endogenous grid onto the exogenous grid in step iv). To do so, we first have to calculate the values of the endogenous grid in this step.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We find the values of the endogenous grid points by using the budget constraint of the household in the non-adjustment case and using that the endogenous grid points being the level of liquid assets today that makes the household choose policies b^*_n(tilde b k h) = b and x^*_n (tilde b k h). Plugging the policy functions into the budget constraint, we then obtain","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"(1+tau^c) x(tilde b k h) + b = y(h) + tilde RR(tilde b) b + r^K k","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"where we used y(h) = left(fractau^p + gamma1+gammaright) y^n + 1h_it neq 0(1- tau)Pi^U + 1h_it = 0 f_tau(Pi^E) to summarize all non-asset income of the household. Note that the endogenous grid points tilde b show up on the left-hand-side as the definition points of the policy functions x^*_n and b (which should be a policy function, but we have fixed the potential choices for liquid assets on the grid), as well as on the right-hand-side as a source of (liquid asset) income. We know the values of the policy functions on the left-hand-side of the budget constraint, such that we can solve for the endogenous grid points","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"tilde b (b k h) = frac1RR(tilde b) left(1+tau^c) x(tilde b k h) + b - y(h) - r^K k right tagend grid non-adj","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Note that the endogenous grid point is a function of todays illiquid asset, k (which is also tomorrows illiquid asset given non-adjustment), as well as the productivity state h, because we have conditionalized in each of the above steps on these states. For the calculation of the endogenous grid points, we evaluate the illiquid capital and the productivity states on the exogenous grids vec k and vec h.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The real interest rate on liquid assets RR(tilde b) can depend on the level of the endogenous grid points. In the baseline case, we have a spread between the lending and borrowing rate, such that only the sign of tilde b is relevant to determine the correct interest rate to be applied. In the code b_tilde_n denotes the endogenous grid of liquid assets, and eff_int is the correct interest rate, which is applied depending on the sign of the endogenous grid.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"b_tilde_n .= (\n    (1.0 .+ τc) .* x_tilde_n .+ n_par.mesh_m .- net_labor_union_inc_GHH .-\n    rental_inc\n)\neff_int =\n    (RL ./ π) .* (b_tilde_n .> 0.0) + (RD ./ π) .* (b_tilde_n .<= 0.0)\nb_tilde_n .= b_tilde_n ./ eff_int","category":"page"},{"location":"Computational Notes/#iv)-Interpolate-back-from-the-endogenous-grid-onto-the-exogenous-grid","page":"Computational Notes","title":"iv) Interpolate back from the endogenous grid onto the exogenous grid","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We cannot use the policy function on the endogenous grid, but require it on the exogenous grid of the liquid asset, vec b. With the endogenous grid points tilde b (b k h), we can interpolate the policy functions from the endogenous grid tilde b on the exogenous grid vec b. For this, we condition on the value of todays (and tomorrows) illiquid asset, k in vec k, and productivity h in vec h and then interpolate the policy function from tilde b(b k h) onto the exogenous grid vec b.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"For the interpolation step, we use a standard linear interpolation routine with a routine that interpolates multiple functions (here the consumption and the liquid asset policy function) at the same time.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"mylinearinterpolate_mult2!(\n    x_n_star[:, kk, jj],\n    b_n_star[:, kk, jj],\n    b_tilde_n[:, kk, jj],\n    x_tilde_n[:, kk, jj],\n    n_par.grid_b,\n    n_par.grid_b,\n)","category":"page"},{"location":"Computational Notes/#v)-Ensure-that-the-borrowing-constraint-is-respected.","page":"Computational Notes","title":"v) Ensure that the borrowing constraint is respected.","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We obtained policy functions x^*_n(b k h) and b^*_n(b k h) assuming that (FOC3) holds with equality, ignoring the borrowing constraint bgeq underlineB. We now ensure that the borrowing constraint is not binding.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Intuitively, we know from the backward step above, that households that choose b = underlineB require to hold tilde b(underline B k h) of liquid assets today. Since underline B is the lowest possible amount of the liquid asset that households can hold in the next period, we know from monotonicity that all households that have less than tilde b(underline B k h) liquid asset holdings today would like to save even less, however, are prohibited from doing so due to the borrowing constraint. Therefore, all grid points on the exogenous grid vec b that satisfy the following condition (conditional on k and h)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginequation*\n    b  tilde b(underline B k h) equiv undersetxmathrmargmin  tilde b(b k h)\nendequation*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"have less (exogenous) resources today than would be required to end up at the borrowing constraint tomorrow in an internal solution. For these points, we know that the households therefore cannot have an internal solution, but that they have to be constrained. Hence, for these households we enforce that b^*_n (b k h) = underline B and","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\n    x(b k h) = frac11+tau^c lefty(h) + RR(b) b + r^K k - underline B right\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"where we used the definition of y(h) from above.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"for jj = 1:nh\n    for kk = 1:nk\n        ...\n        bcpol = b_tilde_n[1, kk, jj]\n        for bb = 1:nb\n            if n_par.grid_b[bb] .< bcpol\n                x_n_star[bb, kk, jj] =\n                    (\n                        net_labor_union_inc_GHH[bb, kk, jj] .+\n                        rental_inc[bb, kk, jj] .+ liquid_asset_inc[bb, kk, jj] .-\n                        n_par.grid_b[1]\n                    ) ./ (1 .+ τc)\n                b_n_star[bb, kk, jj] = n_par.grid_b[1]\n            end\n        end\n    end\nend","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"After these five steps, we have obtained an update of the policy functions x^*_n (bkh) and b^*_n(b k h) in the non-adjustment case. Next, we aim to find updates for the policy functions in the adjustment case x^*_a(bkh), b^*_a(bkh), and k^*_a(b k h).","category":"page"},{"location":"Computational Notes/#b)-Find-optimal-portfolio-combination-in-the-adjustment-case","page":"Computational Notes","title":"b) Find optimal portfolio combination in the adjustment case","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Compared to the non-adjustment case, the adjustment case requires an additional step. Because we choose two assets within the consumption-saving problem in the adjustment case, we cannot directly condition on exogenous values of the two assets. There are portfolio combinations the household would never find optimal to choose. Thus, we need to solve for optimal portfolio combinations in the next period that the household could indeed choose optimally. These combinations are determined by equations (FOC1) and (FOC2), which we repeat here for convenience:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\n    k^*_a quad  fracpartial u(x^*_a)partial x geq (1 + tau^c) q^-1 beta  mathbb E  fracpartial mathbb W (b^*_a k^*_a h)partial k tagFOC1 \n    b^*_a quad fracpartial u(x^*_a)partial x geq (1 + tau^c) beta  mathbb E  fracpartial mathbb W (b^*_a k^*_a h)partial b tagFOC2\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"For an interior portfolio choice, we can combine the two equations to obtain","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"left q^-1 underbracemathbb E fracpartial mathbb W (b^*_a k^*_a h)partial k_EWk (b^*_a k^*_a h) - underbracemathbb E fracpartial W (b^*_a k^*_a h)partial b_EWb(b^*_a k^*_a h) right = 0","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Where we have dropped (1 + tau^c) beta since they do not change the optimal portfolio combination. To find the roots with this equation, we follow the below steps:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"i) Calculate difference between expected marginal value functions of assets on the right-hand-side of (FOC1) and (FOC2).","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"ii) Find the optimal combination of liquid asset hat b and illiquid asset k given a productivity state h.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"iii) Find the optimal consumption policies and the endogenous grid points in the case that the household is only constrained in the liquid asset.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"iv) Find the optimal consumption policies and the endogenous grid points in the case that the household is constrained in the illiquid asset.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"v) Store the results in lists.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We approach this root-finding problem numerically by finding for every k in vec k and h in vec h on-grid some (off-grid) value of the liquid asset in the next period hat b^*_a(k h) such that combining the first-order-conditions for the liquid (FOC2) and illiquid asset (FOC1) in the adjustment case yield","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"left q^-1 EWk (hat b^*_a(k h) k h) - EWb(hat b^*_a(k h) k h) right = 0 tagReturn Difference","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Note again that (by taking expectations over future productivity levels h) the expected continuation value, and thus the solution to the optimal portfolio combination, are a function of todays productivity state h.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Although we illustrate the case here for an interior solution, we are also able to identify corner solutions of the optimal portfolio choice. We will highlight how we handle these at the points in the algorithm where we tackle them.","category":"page"},{"location":"Computational Notes/#i)-Calculate-difference-between-expected-marginal-value-functions-of-assets-on-the-right-hand-side-of-(FOC1)-and-(FOC2)","page":"Computational Notes","title":"i) Calculate difference between expected marginal value functions of assets on the right-hand-side of (FOC1) and (FOC2)","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Before being able to tackle the root-finding problem, we need to calculate the n_b times n_k times n_h array in (Return Difference) on the exogenous grids. Values EWk and EWb are an input into EGM_policyupdate! and therefore can directly be used. We only require to adjust the continuation value for the illiquid asset by the inverse of the price of the illiquid asset q^-1.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The code saves the result in the variable E_return_diff.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"E_return_diff .= ((EWk ./ q) .- EWb)","category":"page"},{"location":"Computational Notes/#ii)-Find-the-optimal-combination-of-liquid-asset-\\hat-b-and-illiquid-asset-k'-given-a-productivity-state-h","page":"Computational Notes","title":"ii) Find the optimal combination of liquid asset hat b and illiquid asset k given a productivity state h","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Having computed the three-dimensional array, we can now compute the root hat b^*_a(k h) that satisfies the optimality condition. Since this value is likely off-grid, we need to employ a numerical approach that allows for hat b^*_a(k h) to be off-grid. The function Fastroot provides a fast way to solve for the root. The function finds a grid point b^-(k h) in vec b conditional on k and h for which the following holds:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"left q^-1 EWk (b^-(k h) k h) - EWb(b^-(k h) k h) right  0  left q^-1 EWk (b^+(k h) k h) - EWb(b^+(k h) k h) right","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"where b^+(k h) is the next highest grid point on the exogenous grid vec b above b^-(k h). Since the expression (Return Difference) changes sign between b^-(k h) and b^+(k h), we know that conditional on k and h, b^-(k h)  hat b^*_a(k h)  b^+(k h). We use the neighboring grid points to calculate the root via a Newton step:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginequation*\nhat b^*_a(k h) = b^-(k h) - fracleft q^-1 EWk (b^-(k h) k h) - EWb(b^-(k h) k h) rightDelta(k h)\nendequation*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"with","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginequation*\nDelta(k h) = left q^-1 EWk (b^+(k h) k h) - EWb(b^+(k h) k h) right - left q^-1 EWk (b^-(k h) k h) - EWb(b^-(k h) k h) right\nendequation*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"denoting the difference of the function values of return difference between the two grid points b^- and b^+.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Uniqueness (conditional on existence) of hat b^*_a follows from the strict concavity of the value function. For some combinations in the state space, we cannot find a root of the equation because the expression is either positive or negative for all values b in vec b.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"If the expression is negative for all values of b in vec b, this implies that the marginal value of the liquid asset is always larger than the marginal value of the illiquid asset. Therefore, the household optimally chooses the highest possible liquid asset holding (restricted to grid values). In this case, we set hat b^*_a(k h) to the highest grid point. While the household is constrained by the grid, in the step iii), we allow the household to hold the amount of bonds that correspond to an interior solution of (Return Difference).\nIf the expression is positive for all values of b in vec b, this implies that the marginal value of the liquid asset is always smaller than the marginal value of the illiquid asset. Therefore, the household chooses the lowest possible liquid asset holding. In this case, we set hat b^*_a(k h) = underline B. Note: In this case, the household is borrowing constrained. Consequently, this represents one scenario where the household does not have an internal portfolio solution.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Fastroot returns an array hat b^*_a(k h) which we need to reshape into an array with dimensions n_k times n_h.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"b_hat_a1 = Fastroot(n_par.grid_b, E_return_diff)\nb_hat_a = reshape(b_hat_a1, (nk, nh))","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"As a result of the root-finding step, we obtain the optimal portfolio combinations that households choose to hold in the liquid and illiquid assets. We can use these optimal portfolio combinations in the next period to execute a similar backward iteration as in the step ii) in a) of the non-adjustment case.","category":"page"},{"location":"Computational Notes/#iii)-Find-the-optimal-consumption-policies-and-the-endogenous-grid-points-in-the-case-that-the-household-is-only-constrained-in-the-liquid-asset","page":"Computational Notes","title":"iii) Find the optimal consumption policies and the endogenous grid points in the case that the household is only constrained in the liquid asset","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"With the optimal portfolio combinations  hat b^*_a(k h) k  we can use the first-order condition (FOC2) to find optimal consumption x^*_a conditional on choosing an optimal portfolio in the next period. In contrast to step ii) in a), we do not condition on the exogenous grid point of the liquid asset, however do so for the illiquid asset at the exogenous grid points k in vec k and the corresponding optimal holding of liquid assets hat b^*_a(k h).","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"It is important to recall that when the household can trade its illiquid assets, the portfolio composition itself is irrelevant for the household's future portfolio choices. All that matters to the household are its total financial ressources tildemathcalR: its assets plus their returns.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Let tildemathcalR_a(k h) denote the endogenous grid points of total non-human resources that are compatible with plans (hat b^*_a(k h) k) and a consumption policy x_a^* left( tildemathcalR_a(k h) h right) in total resources. We can then calculate the consumption policy function on the endogenous grid of resources by inverting the first-order condition (FOC2) evaluated at the optimal portfolio combination (hat b^*_a (k h) k).","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"x_a^* left( tildemathcalR_a(k h) h right) = (u)^-1 EMU(hat b^*_a (k h) k h)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Above, we have calculated the expression EMU(b k h), which is defined on the exogenous grids. Consequently, before applying the inverse of the marginal utility, we need to interpolate the expression from the exogenous grid to the optimal portfolio choices.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The code does this by conditioning on each state k and h individually, but it does so in a computationally efficient way by iterating over eachindex(b_hat_a). The eachindex function allows for linear indexing through arrays. The following code finds the points on the grid next to the roots hat b^*_a (k h), conditional on k and h. hat b^*_a (k h) is hereby assigned to the placeholder variable xi in every specific iteration over (k', h). If the optimal portfolio choice is anywhere above the second highest grid point (or even above the highest grid point), the left-hand-side interpolation value is defined as the second highest grid point and its location is saved in idx. If the optimal portfolio choice is equal to or below the lowest grid point, the left-hand-side interpolation value is defined as the lowest grid point. The choice of the grid points will become clear in the next step before interpolating and extrapolating respectively.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"if xi .> n_par.grid_b[nb - 1]\n        idx = nb - 1\n    elseif xi .<= n_par.grid_b[1]\n        idx = 1\n    else\n        idx = locate(xi, n_par.grid_b)\n    end","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The code then computes the interpolation weight s to the next lowest grid point according to","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginequation*\ns = fracxi - vec b_idxvec b_idx+1 - vec b_idx\nendequation*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"where vec b_idx denotes the value of the grid vec b evaluated at its idx's entry. We calculate the distance to the next lowest grid point such as to be able to extrapolate at the top. The code mirrors the expression:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"s = (xi .- n_par.grid_b[idx]) ./ step[idx]","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Lastly, we interpolate EMU from the exogenous grid on the optimal liquid asset choice hatb^*_a(k h) using the interpolation weight s. The interpolated variable EMU(hat b^*_a (k h) k h) is saved in the variable EMU_star. Note that for the case where the optimal portfolio choice is above the highest grid point, s is above 1, which implies linear extrapolation with negative weights on the left-hand-side, that is s is above 1 and the weight assigned to the second highest grid point is negative. For the case where the optimal portfolio choice is below the lowest grid point, s is equal to or below 0, which implies linear extrapolation with negative weights on the right-hand-side.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"EMU_star[j] =\n    (EMU[idx .+ aux_index[j]] .* (1.0 - s)) .+\n    (s .* (EMU[idx .+ aux_index[j] .+ 1]))\n","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"With EMU(hat b^*_a (k h) k h), we can find optimal consumption on the endogenous grid through inversion of the first-order condition FOC2. Note that in case the liquid asset constraint holds and households' m'(k',h) lies at the borrowing constraint, consumption can still be calculated in this backwards EGM.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"x_tilde_a = invmutil(EMU_star, m_par)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"With the policy function for consumption on the endogenous grid, we can now find the endogenous grid points tildemathcalR using the budget constraint:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"tildemathcalR_a(k h) = (1+tau^c) x^*_a(tildemathcalR_a(k h) h) + hat b^*_a (k h) + q k - y(h) tagend grid adj","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"where we used y(h) = left(fractau^p + gamma1+gammaright) y^n + 1h_it neq 0(1- tau)Pi^U + 1h_it = 0 f_tau(Pi^E) again to denote non-asset income.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Note: The definition of the endogenous grid points tildemathcalR in the adjustment case differs from the non-adjustment case. In the non-adjustment case, the endogenous grid points tilde b(b k h) were a function of today's holdings of the illiquid asset since adjustments to illiquid assets were not possible. However, in the adjustment case, the household's resources come from both liquid and illiquid assets. Therefore, we do not need to identify the composition of today's asset portfolio. The household only cares about the total amount of resources available. Consequently, the policy functions are defined over total resources tildemathcalR rather than separate grids for liquid and illiquid assets.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The endogenous grid points are calculated and allocated to the variable R_tilde_a in the code as follows:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"R_tilde_a =\n        (1.0 .+ τc) .* x_tilde_a .+ b_hat_a .+ capital_liquidation_inc[1, :, :] .-\n        net_labor_union_inc_GHH[1, :, :]","category":"page"},{"location":"Computational Notes/#iv)-Find-the-optimal-consumption-policies-and-the-endogenous-grid-points-in-the-case-that-the-household-is-constrained-in-the-illiquid-asset","page":"Computational Notes","title":"iv) Find the optimal consumption policies and the endogenous grid points in the case that the household is constrained in the illiquid asset","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"So far, we have determined policies for assets and consumption, as well as the endogenous grid points for cases where households have an interior solution to the portfolio problem or are constrained in the liquid asset. Next, we address the scenario where households are constrained in the illiquid asset.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"When finding the optimal portfolio combination, we also considered the case where k=0. Thus, we have already identified an optimal portfolio for households constrained in the illiquid asset, specifically (hat b^*_a(0 h) 0). However, this combination may not be the only optimal holding of liquid assets when households choose not to save in the illiquid asset. The following figure illustrates why this is the case.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"(Image: image)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Figure 1 illustrates the optimal combination of savings in liquid and illiquid assets for two values of h. The solid blue line represents the optimal levels of the liquid asset b_a^*(k h) for different levels of k, corresponding to the combinations obtained in step iii). The solid red line shows alternative liquid asset choices that households might consider when k=0. The red line indicates values on the grid of the liquid asset b, which satisfy 0 leq b  hat b^*_a(0 h_1) and still be optimal for the household given corresponding endogenous resources. Such choices might emerge if the illiquid asset is very undesirable to hold, meaning the household is constrained in its illiquid asset choice but not in its liquid asset choice.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"This step is crucial because, in dynamic programming, we need to determine the optimal choices when the household is constrained in the illiquid asset to define the policy function across the entire state space. If points on the red line exist, we have not covered this case. From the perspective of implementing the EGM algorithm, during the EGM step, we must condition on all optimal future asset holdings. In the non-adjustment case, this is straightforward by conditioning on the exogenous grid vec b. However, in the adjustment case, this is more complex as we need to condition on the optimal portfolio choice. The red line represents portfolio choices in the liquid asset, conditional on k = 0, which might still be optimal for the household but were not identified in step iii). Therefore, we must identify the policy functions on the endogenous grid today that correspond to the asset choices on the red line and find the endogenous grid points associated with these choices. This completes the array of endogenous grid points from which we interpolate policy functions onto the exogenous grid.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"To verify whether there exist values on the exogenous grid vec b that were not covered in step iii) (i.e., are located on the red line in Figure 1), we need to check for all values of h in vec h. Conditional on a productivity level h, we check whether there exist values on the exogenous grid vec b that satisfy b  b^*_a(0 h). If such values exist, we have identified points where households are constrained in their illiquid asset choice but still prefer to hold liquid assets below b^*_a(0 h) given their endogenous resources. If no such values exist, all liquid asset choices on the exogenous grid were already covered in step iii). We illustrate this case with the dotted blue line in Figure 1, where hatb^*_a(0 h_2)=underlineB.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The code checks whether there exists liquid asset values as on the red line using an if condition. Note that b_hat_a[1, :] corresponds to the optimal liquid asset choice b^*_a(0 h) conditional on k=0 for all n_h values of productivity. It is thus a vector of dimension n_h:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"b_star_zero = b_hat_a[1, :]","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We loop over all productivity states j=1:nh as follows. There are two cases for the optimal portfolio choice of liquid assets under a binding illiquid assets constraint. In the first case, the lowest grid point on the exogenous grid vec b is below the optimal choice b^*_a(0 h), so:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"b_star_zero[j] > n_par.grid_b[1]","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"is true. This indicates the existence of points on the red line in Figure 1. We need to address these points and determine the optimal consumption choices and endogenous grid points associated with these grid points. First, we identify the grid points on the exogenous grid vec b that are below the interior choice b^*_a(0 h). Then, we apply the same logic as in the EGM step for the non-adjustment case. We use the first-order condition (FOC2), condition on the identified grid points in vec b and k=0, and invert the first-order condition to find the optimal corresponding consumption policy. Using the computed policy for consumption, as well as liquid and illiquid savings (k=0), we then compute the endogenous grid points.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Since all asset choices are on the exogenous grid, we do not need to interpolate the continuation value on the right-hand-side of (FOC2). Additionally, we do not need to apply the inverse of the marginal utility to the right-hand-side of (FOC2) because we have already calculated these expressions in step ii) in a), the EGM step for the non-adjustment case. Therefore, we can directly use the consumption function on the endogenous grid x_tilde_n obtained in the non-adjustment case as the relevant policy function.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The intuition for us to use the consumption function from the non-adjustment case is that k=k (the non-adjustment case) and k=0 (in the adjustment case) are equivalent as soon as we express everything in terms of the endogenous grid points (resources). This can be seen by looking at the value functions from the very beginning:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\n    V^a (bkh) = max_kb in Gamma_a  ux(bb_akkh) + beta  mathbb E  mathbb W (bkh) \n    V^n (bkh) = max_b in Gamma_n  ux(bb_nkkh) + beta  mathbb E  mathbb W(bkh)\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"If we collect the contemporaneous b, and k terms in the term mathcalR and noting that for the adjustment case, we know that k=0, then","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\n    V^a (mathcalR h) = max_b in Gamma_a  ux(mathcalRb_a0 h) + beta  mathbb E  mathbb W (b0h) \n    V^n (mathcalR h) = max_b in Gamma_n  ux(mathcalRb_nk h) + beta  mathbb E  mathbb W(bkh)\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"so that using the results from the non-adjustment case for k=0 is equivalent since, conditional on the resources, also the budget sets are identical then.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Consequently, we reuse the consumption function and save it in a new variable for reference in the following code.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"aux_x = reshape(x_tilde_n[:, 1, :], (nb, nh))","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We do the same with net labor income, which only depends on the productivity state.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"aux_inc = reshape(net_labor_union_inc_GHH[1, 1, :], (1, nh))","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Technical note: In the code, we now save the results of the endogenous grid algorithm in lists. In the later interpolation step, we will then use these lists as inputs to the interpolation function.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"cons_list = Array{Array{eltype(x_tilde_n)}}(undef, nh, 1)\nres_list = Array{Array{eltype(x_tilde_n)}}(undef, nh, 1)\nliq_list = Array{Array{eltype(x_tilde_n)}}(undef, nh, 1)\ncap_list = Array{Array{eltype(x_tilde_n)}}(undef, nh, 1)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We introduce the lists at this point together with a placeholder index log_index. The latter is used to save the locations on the exogenous grid vec b of liquid assets, where we have b leq b^*_a(0 h) for a fixed h.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"log_index = Vector{Bool}(undef, n_par.nb)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Lists initialized with undef have one undesirable feature: you cannot append arrays to such lists; you need to overwrite them. However, in the second case (h_2 and the dotted blue line in Figure 1), we  already covered all liquid asset holdings as interior solutions in Fastroot, and we only want to append these results in the next step. To handle this, we allocate an empty array to the lists if we are not in the first case (h_1 and the solid blue line in Figure 1) but in the second case.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Finally, the code goes as follows (and explanation follows):","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"for j = 1:nh\n\n    if b_star_zero[j] > n_par.grid_b[1]\n\n        log_index .= n_par.grid_b .< b_star_zero[j]\n\n        x_k_cons = aux_x[log_index, j]\n        cons_list[j] = x_k_cons\n\n        liquid_assets = n_par.grid_b[log_index]\n        liq_list[j] = liquid_assets\n        res_list[j] = liquid_assets .+ (1.0 .+ τc) .* x_k_cons .- aux_inc[j]\n        cap_list[j] = zeros(eltype(EWb), sum(log_index))\n\n    else\n\n        cons_list[j] = zeros(eltype(EWb), 0)\n        res_list[j] = zeros(eltype(EWb), 0)\n        liq_list[j] = zeros(eltype(EWb), 0)\n        cap_list[j] = zeros(eltype(EWb), 0)\n    end\nend","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"When the if condition is valid, log_index saves the location of the grid points in vec b where households are constrained in the illiquid asset choice but still want to save in the liquid asset. We then find the consumption policy that corresponds to these points by applying log_index to aux_x and save the result to the consumption list cons_list. Moreover, we save the corresponding liquid asset choices b to liq_list. The endogenous grid points are calculated according to the budget constraint","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"tildemathcalR_a(b h) = (1+tau^c) x^*_n(tildemathcalR_a(0 h) h) + b - y(h)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"and saved to res_list. Note that capital does not show up since k=0. Moreover, we directly use the policy function x^*_n for the calculation of the required endogenous grid points. Finally, we save zeros in the length of the number of grid points in vec b that are below b^*_a(0 h) to cap_list, since all lists have to be of equal length in the interpolation step later.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"If the if condition is not valid, the algorithm goes to the else section, where the undef in the lists is replaced by an array of zero length. This is done to prepare the next step.","category":"page"},{"location":"Computational Notes/#v)-Store-the-results-in-lists","page":"Computational Notes","title":"v) Store the results in lists","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"With steps iii) and iv), we have covered all potentially optimal savings choices in the next period. Next, we want to prepare the inputs for the interpolation step of EGM. In iv), we already allocated some of the interpolation points to the lists cons_list, res_list, liq_list, and cap_list. Next, we save the policy functions and endogenous grid points we obtained in step iii):","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"for j = 1:nh\n    append!(cons_list[j], x_tilde_a[:, j])\n    append!(res_list[j], R_tilde_a[:, j])\n    append!(liq_list[j], b_hat_a[:, j])\n    append!(cap_list[j], n_par.grid_k)\nend","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We iterate over all productivity states in vec h and use the append! command to add the calculated policy functions and endogenous grid points to their respective lists. By first adding the points in step iv), which correspond to the case where the household is constrained in the illiquid asset choice, we ensure that the entries in the list remain monotone.","category":"page"},{"location":"Computational Notes/#c)-Standard-backward-EGM-step-given-the-optimal-portfolio-choice","page":"Computational Notes","title":"c) Standard backward EGM step given the optimal portfolio choice","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Finally, we can update the policy functions based on a similar interpolation step as in the non-adjustment case. Thus, we are left with the following two steps:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"i) Interpolate back to fixed grid.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"ii) Check for binding of both borrowing constraints.","category":"page"},{"location":"Computational Notes/#i)-Interpolate-back-to-the-fixed-grid","page":"Computational Notes","title":"i) Interpolate back to the fixed grid","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"As a result of the above steps, we obtained the ordered pairs left(tildemathcalR_a(k h) x^*_a left( tildemathcalR_a(k h)  h right) right), left(tildemathcalR_a(k h) b^*_a left( tildemathcalR_a(k h)  h right) right), and left(tildemathcalR_a(k h) k right). We will interpolate the policy functions from the endogenous grid points tildemathcalR_a(k h) onto the exogenous grid points.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Note that the endogenous grid points are total non-human resources today. Consequently, the exogenous grid points we evaluate the policy functions in the interpolation step need to be total nun-human resources, as well. We calculate the exogenous non-human resources as","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"mathcalR_a = RR(b) b + (q + r^K) k tagresources adjustment","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"with b and k on their respective exogenous grids. We store the resulting exogenous grid points in the variable R_exo_a. Finally, the code interpolating the policy functions from the endogenous grid res_list onto the exogenous grid R_exo_a is:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"@views @inbounds begin\n    for j = 1:nh\n\n        mylinearinterpolate_mult3!(\n            x_a_star[:, :, j][:],\n            b_a_star[:, :, j][:],\n            k_a_star[:, :, j][:],\n            res_list[j],\n            cons_list[j],\n            liq_list[j],\n            cap_list[j],\n            R_exo_a[:, j],\n        )\n\n        # ...\n    end\nend","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The [:] after all policy functions (denoted by _a_star) flattens the array to match the dimensions of R_exo_a. This use of [:] ensures efficient interpolation. The interpolation function uses the ordered pairs of endogenous grid points and policy functions to find the corresponding policy function values for each entry in R_exo_a[:, j]. The [:] ensures that the interpolated policy function values are stored in the same order as the R_exo_a values.","category":"page"},{"location":"Computational Notes/#ii)-Check-for-binding-of-both-borrowing-constraints","page":"Computational Notes","title":"ii) Check for binding of both borrowing constraints","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Finally, we need to check for the case where both the liquid and illiquid asset constraints are binding.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"To identify whether households at certain states are borrowing constrained, we use the same logic as in the non-adjustment case. Conditional on a productivity level h, we know the endogenous resources mathcaltildeR_a(0h) that households require today to be constrained in liquid and illiquid assets tomorrow. From monotonicity, we know that all households with fewer total resources mathcalR_a today would like to save less. Since they are prohibited from saving less by the constraints, we know that on all grid points of the exogenous grid mathcalR_a that satisfy the following condition:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"mathcalR_a  min mathcaltildeR_a(0h)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"households need to be constrained. For these households, we enforce that b^*_a (b k h) = underline B, k^*_a(bkh) = 0, and","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"x^*_a(b k h) = frac11+tau^c lefty(h) + RR(b) b + (q + r^K) k - underline B right","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The code implements this as follows:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"@views @inbounds begin\n    for j = 1:nh\n\n        # ...\n\n        log_index2[:] .= reshape(R_exo_a[:, j], nb * nk) .< res_list[j][1]\n        x_a_star[:, :, j][log_index2] .=\n            (R_exo_a[log_index2, j] .+ labor_inc_grid[j] .- n_par.grid_b[1]) ./ (1.0 .+ τc)\n        b_a_star[:, :, j][log_index2] .= n_par.grid_b[1]\n        k_a_star[:, :, j][log_index2] .= 0.0\n    end\nend","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"This step concludes the updating of the policy functions.","category":"page"},{"location":"Computational Notes/#3.-Update-the-continuation-values-(CV1)-and-(CV2)-using-the-Envelope-conditions-(EC1)-(EC4).","page":"Computational Notes","title":"3. Update the continuation values (CV1) and (CV2) using the Envelope conditions (EC1) - (EC4).","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Finally, we calculate updated continuation values fracpartial W^mpartial b and fracpartial W^mpartial k based on the Envelope conditions and the continuation values of the previous iteration. We repeat the equations with the correct iterations attached here. Note that all policy functions are derived from this iteration m:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\n    fracpartial V_a^mpartial k(b k h) = fracpartial ux^*_a(b k h)partial x left( fracq + r^K1 + tau^c right) tagEC1 \n    fracpartial V_a^mpartial b(b k h) = fracpartial ux^*_a(b k h)partial x RR(b) frac11 + tau^c tagEC2 \n    fracpartial V_n^mpartial b(b k h) = fracpartial ux^*_n(b k h)partial x RR(b) frac11 + tau^c tagEC3 \n    fracpartial V_n^mpartial k(b k h) = fracpartial ux^*_n(b k h)partial x left(fracr^K1 + tau^cright) + beta mathbbE fracpartial mathbb W^m-1 b^*_n(b k h) k hpartial k tagEC4 \n    fracpartial mathbb W^mpartial k (b k h) =  lambda fracpartial V_a^m (b k h)partial k + (1 - lambda)fracpartial V_n^m (b k h)partial k tagCV1 \n    fracpartial mathbb W^mpartial b (b k h) = lambda fracpartial V_a^m (b k h)partial b + (1 - lambda)fracpartial V_n^m (b k h)partial b tagCV2\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Hence, we use the updated policy functions from step 2 above and last iterations fracpartial W_n^m-1partial k to update the continuation values in updateW.jl in the function updateW!.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The updating of the marginal value for liquid assets (CV1) is straight forward:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Compute the marginal utility of consumption in the non-adjustment case with mutil!(Wb, x_n_star, m_par)\nCompute marginal utility of consumption in the adjustment case with mutil!(mutil_x_a, x_a_star, m_par)\nCalculate the marginal continuation value as the probability-weighted sum of marginal utility of consumption:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Wb .= m_par.λ .* mutil_x_a .+ (1.0 - m_par.λ) .* Wb\nWb .= Wb ./ (1.0 .+ τc)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The continuation value of the illiquid asset has a recursive structure. Therefore, updating the continuation value of the illiquid asset requires on additional interpolation step to evaluate last periods marginal value fracpartial mathbb W^m-1partial k at b^*_n(b k h).","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"@inbounds @views begin\n    for j::Int = 1:nh\n        for k::Int = 1:nk\n            mylinearinterpolate!(\n                Wk[:, k, j],\n                n_par.grid_b,\n                invmutil(EWk[:, k, j], m_par),\n                b_n_star[:, k, j],\n            )\n        end\n    end\nend","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We interpolate a transformation of the continuation value EWk by applying the inverse of the marginal utility function invmutil to it. With this transformation, we are able to extrapolate at the top for very high optimal liquid asset holdings. Extrapolating the monotonically decreasing function otherwise might result in negative interpolated continuation values. After the interpolation, we revert the transformation by applying the marginal utility mutil.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Wk .= mutil(Wk, m_par)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Finally, we can update the continuation value fracpartial mathbb W^mpartial k as the probability-weighted sum of the marginal values of illiquid assets in the two cases of adjustment (note the difference in the notation in the code and in the document):","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Wk .= rK .* Wb .+ m_par.λ .* q .* mutil_x_a ./ (1.0 .+ τc) .+ (1.0 .- m_par.λ) .* β .* Wk","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"This expression directly follows from the Envelope Conditions (EC1) and (EC4) and the definition of the marginal continuation value of illiquid asset holdings (CV1) as above. Plugging the Envelope Conditions into the definition for the marginal continuation value gives:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\n    fracpartial mathbb Wpartial k (b k h) = lambda fracpartial ux^*_a(b k h)partial x left( fracq + r^K1 + tau^c right) + (1- lambda)fracpartial ux^*_n(b k h)partial x left(fracr^K1 + tau^cright) \n    + (1-lambda) beta  mathbbE fracpartial mathbb W b^*_n(b k h) k hpartial k \n    iff fracpartial mathbb Wpartial k (b k h)\n    = lambda fracpartial ux^*_a(b k h)partial x left( fracq1 + tau^c right) \n    + left(lambda fracpartial ux^*_a(b k h)partial x + (1- lambda)fracpartial ux^*_n(b k h)partial x right) left(fracr^K1 + tau^cright) \n    + (1- lambda) beta  mathbbE fracpartial mathbb W b^*_n(b k h) k hpartial k tagCV1a\n\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Take the definition of the marginal continuation value of liquid assets (CV2) combined with Envelope Conditions (EC1) and (EC2):","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\n    fracpartial mathbb Wpartial b (b k h) = RR(b) cdot\n    left(lambda fracpartial ux^*_a(b k h)partial x + (1- lambda)fracpartial ux^*_n(b k h)partial x right) cdot frac11 + tau^c\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The object Wb created after the first part of this step 3, is the marginal continuation value of liquid assets, without premultiplied real interest rates (RR(b)), but already divided by the consumer tax. We can thus multiply Wb by the rental rate of capital rK and plug it into equation (CV1a) instead of the middle term left(lambda fracpartial ux^*_a(b k h)partial x + (1- lambda)fracpartial ux^*_n(b k h)partial x right) left(fracr^K1 + tau^cright). And we hereby arrive at the expression for the marginal continuation value as implemented in the code.","category":"page"},{"location":"Computational Notes/#4.-Check-convergence-of-the-(inverse)-continuation-values","page":"Computational Notes","title":"4. Check convergence of the (inverse) continuation values","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Lastly, we check whether the continuation values have changed between iterations back in fcn_ksupply. Instead of comparing the continuation values directly, we transform them using the inverse of the marginal utility and store them in the variables iWk_new and iWb_new. This transformation ensures that even small changes in the continuation values can be detected:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"invmutil!(iWk_new, Wk_new, m_par)\ninvmutil!(iWb_new, Wb_new, m_par)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Formally, if","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"max left( left(fracpartial W^mpartial kright)^-frac1sigma - left(fracpartial W^m-1partial k right)^-frac1sigma   left( fracpartial W^mpartial b right)^-frac1sigma - left( fracpartial W^m-1partial b right)^-frac1sigma  right)  epsilon","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"for some small epsilon, the algorithm has converged, otherwise repeat steps 1 to 3.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"In the code, we implement this by defining the maximum distance of continuation values from previous iteration and current iteration as above:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"D1 .= iWk_new .- iWk\nD2 .= iWb_new .- iWb\ndist1 = maximum(abs, D1)\ndist2 = maximum(abs, D2)\n\ndist = max(dist1, dist2)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Then this distance is used for the stopping criterion of the while loop of fcn_ksupply. This determines whether the algorithm has converged or whether steps 1 to 3 are repeated:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"while dist > n_par.ϵ && count < 10000\n    # ...","category":"page"},{"location":"Computational Notes/#Aggregation-via-non-stochastic-simulations","page":"Computational Notes","title":"Aggregation via non-stochastic simulations","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"This section illustrates aggregation via non-stochastic simulations based on the method of Young (2010). Young introduces a method that replaces traditional stochastic simulations with a non-stochastic counterpart. Instead of approximating the distributions of households by simulating a large cross-section of households stochastically, Young's method directly simulates the distribution of households. This approach involves iterating on a fixed grid of points to approximate the distribution of individual states, thereby eliminating the sampling variability inherent in stochastic simulations. The non-stochastic simulation aims to improve computational efficiency and accuracy in solving models with heterogeneous agents.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Below, we will illustrate the idea of Young's method based on the household problem of a Krusell and Smith economy as in the original paper. We will demonstrate how Young's method allows us to find the transition matrix Gamma_t, before illustrating the application of the method to the calculation of the steady state, as well as the movement of the distribution over time. In line with the former section, we use the expressions vec b, vec k, and vec h for the exogenously given vectors over which we discretize the continuous state space, and n_b, n_k, and n_h denote their respective sizes.","category":"page"},{"location":"Computational Notes/#Young's-method-applied","page":"Computational Notes","title":"Young's method applied","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Written more abstractly, Young's method finds the transition matrix Gamma_t, which allows expressing the dynamics of a distribution over the state space as:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Theta_t+1(b k h) = Theta_t(b k h) Gamma_t tagLOM Distribution","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Gamma_t","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"is the transition matrix that maps households from today's state space to tomorrow's state space. Intuitively, Gamma_t redistributes the current masses of households over the state space Theta_t(b k h) to the points in the state space associated with their policy functions (b^*_n b^*_a k^*_a) for the next period. Since the policy functions yield continuous, off-grid values, Young's method employs linear interpolation between grid points to find the weights for redistributing agents from today's state space to tomorrow's state space. This ensures that the redistribution maintains the same mean as the policy function. The figure below (Figure 1 in Young (2010)) illustrates the intuition behind the method.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"note: Note\nYoung's model differs from the model we use. Young illustrates the methodology for a Krusell and Smith economy, where households have two idiosyncratic states varepsilon_t. Households can either be employed (varepsilon_t = e) or unemployed (varepsilon_t = u). Households fluctuate between idiosyncratic states according to pi_varepsilon_t varepsilon_t+1. Facing the idiosyncratic risk, households optimally choose their savings in the liquid asset k, with the policy function being denoted as g(k_t varepsilon_t). For illustration purposes, k_t and k_t+1 are used to represent the grid values vec k in this environment.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"(Image: Illustration of Method)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Figure 1 of Young (2010)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The bottom two lines represent the capital grid k_t today for both employed (top) and unemployed (bottom) agents. The arrows indicate the optimal choice of k^* = g(k_t varepsilon_t) for each type as colored dots at the top two lines. For example, households at the illustrated grid point k that are employed (varepsilon_t = e) would like to save g(k e), illustrated by the purple and teal dots. However, this optimal savings decision lies between grid points illustrated in blue, requiring us to find weights omega for the neighboring grid points. These weights ensure that the policy choice is accurately represented as a gamble over grid points. By doing so, we preserve the values of the policy functions for each individual point in the state space (b k h). Finally, we weight the measure of agents transitioning between each state varepsilon_t and varepsilon_t+1 using pi_varepsilon_t varepsilon_t+1, which denotes the transition probability of individual states.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Having illustrated the intuition based on Young's original model, we now apply the methodology to determine the individual elements of the transition matrix Gamma_t in our specific context.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Consider a generic period t during the simulation, with the current distribution over the discretized state-space Theta_t(bkh). Associated with the distribution are policy functions b^*_a(b k h), b^*_n(b k h), and k^*_a(bkh). Given these policy functions, we need to locate them within the grids. Specifically, for both the adjustment and non-adjustment cases, we need to find the indices j_b and j_k such that b^*_i(b k h) in vec b_j_b vec b_j_b+1 for i in a n, and k^*_a(b k h) in vec k_j_k vec k_j_k+1. Essentially, we are identifying the indices j_b and j_k on the exogenous grids vec b and vec k that are closest but lower than the values of the policy functions.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We want to relocate the current mass Theta_t (b k h) to the points (vec b_j_b vec k_j_k h), (vec b_j_b + 1 vec k_j_k h), (vec b_j_b vec k_j_k + 1 h), and (vec b_j_b + 1 vec k_j_k + 1 h) according to the weights omega_b omega_k Pi(h h), (1 - omega_b) omega_k Pi(h h), omega_b (1 - omega_k) Pi(h h), and (1 - omega_b)(1 - omega_k) Pi(h h), with Pi(hh) denoting the transition probability between idiosyncratic states.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginalign*\n    omega_b (bkhi) = 1 - fracb^*_i(b k h) - vec b_j_bvec b_j_b+1 - vec b_j_b tagweight liquid \n    textand quad omega_k (b k h i) = 1 - frack^*_i(b k h) - vec k_j_kvec k_j_k+1 - vec k_j_k tagweight illiquid\nendalign*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The weights depend on the current position in the state space, as they impact the optimal policy choice of the household, and on whether households are in the adjustment case (i = a) or in the non-adjustment case (i = n). Note that the policy function for the illiquid asset in the non-adjustment case is k^*_n (b k h) = k, such that omega_k (b k h n) = 1. The weights determine the measure of agents who move to the discrete realizations of the state space (b k h), and the omega's are then a reassignment of individuals to the endpoints of the interval, where the weights are determined by how close the true decision rule lies to each endpoint. Provided that the grid is sufficiently dense, the relocation of mass does not materially affect the outcomes for any agents.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"After defining the weights, we can characterize the individual components of the transition matrix Gamma_t. Denote by j_b(b k h i) and j_k(b k h i) the mapping between today's position in the state space and the indices the policy functions of the liquid and the illiquid asset map to. Then we can define Gamma_t by its individual components gamma^i_(b k h) rightarrow (b k h) as follows:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginequation*\n    gamma^i_(b k h) rightarrow (b k h) =\n        begincases\n            omega_b(bkhi) omega_k(bkhi) Pi(h h)  textif  b = vec b_j_b(bkhi) text and  k = vec k_j_k(bkhi) \n            (1 - omega_b(bkhi)) omega_k(bkhi) Pi(h h)  textif  b = vec b_j_b(bkhi)+1 text and  k = vec k_j_k(bkhi) \n            omega_b(bkhi) (1 - omega_k(bkhi)) Pi(h h)  textif  b = vec b_j_b(bkhi) text and  k = vec k_j_k(bkhi)+1 \n            (1 - omega_b(bkhi)) (1 - omega_k(bkhi)) Pi(h h)  textif  b = vec b_j_b(bkhi)+1 text and  k = vec k_j_k(bkhi)+1 \n            0  textelse taggamma\n        endcases\nendequation*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Then Gamma_t^i = left gamma^i_(b k h) rightarrow (b k h) right_(b k h)^(b k h) represents a stochastic transition matrix of a discretized Markov Chain on the vectorized state space (vec b vec k vec h). Note that the transition matrix still depends on whether the household is in the adjustment (i = a) or non-adjustment case (i = n). We must weight the transition matrices of the individual cases by their respective probabilities of occurrence, such that Gamma_t = lambda Gamma_t^a + (1 - lambda) Gamma_t^n.","category":"page"},{"location":"Computational Notes/#Finding-the-Steady-State","page":"Computational Notes","title":"Finding the Steady State","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"In the steady state, all aggregate quantities, prices, and the distribution of households over the state-space are time-invariant. This does not imply, however, that households do not move over the state space. Due to idiosyncratic risk and optimal choices, households still fluctuate over the discretized state space. However, because prices are constant, the policy functions are also time-invariant. This implies that the transition matrix Gamma_t is time-invariant as well. Hence, the law of motion for the distribution is:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"beginequation*\n    Theta_t+1(b k h) = Theta_t(b k h) Gamma\nendequation*","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"If an (ergodic) stationary distribution of households over the state-space, Theta (b k h), exists, it is given by the left unit eigenvector of Gamma. This is precisely what we compute when searching for the steady state distribution.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The implementation in the code requires several steps, all of which are executed within the function SteadyState.Ksupply(). These steps are as follows:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Calculate the Policy Functions: This is done using the Endogenous Grid Method (EGM) algorithm. For detailed information on this step, refer to the section Algorithm of the Endogenous Grid Method.\nCalculate the Transition Matrix: The transition matrix Gamma is computed to map households from today's state space to tomorrow's state space. This involves determining the weights and indices for the transitions based on the policy functions.\nFind the Left Unit Eigenvector of the Transition Matrix: The left unit eigenvector of the transition matrix represents the steady-state distribution of households over the state space. This eigenvector is computed to ensure that the distribution is normalized and corresponds to a valid distribution.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Below, we illustrate the implementation of steps two and three in detail.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The matrix Gamma is typically sparse, meaning many entries of the matrix are zero. This allows us to use sparse matrices to speed up calculations. In Julia, creating a sparse matrix involves specifying starting indices, target indices, and weights. The starting and target indices will take values of a linear index associated with the three-dimensional Cartesian location in the state-space. For more information about linear indexing in Julia, refer to this link.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We prepare all the necessary objects to create the sparse array in the function MakeTransition. Within the function, we use the function MakeWeights that handles finding the indices j_k_a, j_b_a, and j_b_n, as well as the corresponding weights omega_b and omega_k, and their right-hand-side counterparts, which are 1 - omega_b and 1 - omega_k.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"j_k_a, ω_left_k_a, ω_right_k_a = MakeWeights(k_a_star, n_par.grid_k)\nj_b_a, ω_left_b_a, ω_right_b_a = MakeWeights(b_a_star, n_par.grid_b)\nj_b_n, ω_left_b_n, ω_right_b_n = MakeWeights(b_n_star, n_par.grid_b)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We then iterate over the entire state space of the household today to find the associated location in the future state space (b k h) that the policy functions map to, starting from the current position (b k h). We call this the startindex. The future state space location is referred to as the targetindex, and the probability gamma^i_(b k h) rightarrow (b k h) that a household transitions there is called the weight. This process is done separately for the adjustment and non-adjustment cases.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Below, we illustrate the adjustment case, which is slightly more complex than the non-adjustment case. In the adjustment case, households choose two asset policies. For each policy choice, the realization of the policy function lies between two grid points for either the liquid or the illiquid asset. Unlike the illustration based on Young's example above, we need to interpolate two policy choices between four grid points in the liquid-illiquid state-space. Given indices j_b_a and j_k_a, we need to calculate the weights associated with transitioning to the locations in the state space (j_b_a j_k_a), (j_b_a j_k_a+1), (j_b_a+1 j_k_a), and (j_b_a+1 j_k_a+1).","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We initialize the containers for the variables that we aim to fill within a loop:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"weight_adj =\n    Array{eltype(k_a_star),3}(undef, 4, n_par.nh, n_par.nk * n_par.nb * n_par.nh)\ntargetindex_adj = Array{Int,3}(undef, 4, n_par.nh, n_par.nk * n_par.nb * n_par.nh)\nstartindex_adj = Array{Int,3}(undef, 4, n_par.nh, n_par.nk * n_par.nb * n_par.nh)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The dimensions here show the benefits of linear indexing, as we only require three dimensions for the mapping, and are to be understood as follows: The four grid points to the left and right of the two asset choices and all future productivity states characterize tomorrows state space, which is reachable from the point on today's state space with linear index of length n_par.nk * n_par.nb * n_par.nh.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We also set up the so-called blockindex, which corresponds to the change in the linear index when moving one point up in the productivity grid h. This represents how much the linear index of the state space changes due to an increase in the productivity space. Finally, we set up the runindex, which corresponds to the current position in the state space, saved as a linear index. The following lines of code illustrate this:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":" blockindex = (0:(n_par.nh - 1)) * n_par.nk * n_par.nb\n\nrunindex = 0","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Iterating over all states (indicated by the indices hh, kk, and bb), we first calculate the four weights (noted by ωLL, ωLR, ωRL, and ωRR) corresponding to the gambles to transit to the respective grid points due to the policy function.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"for hh = 1:(n_par.nh)\n    for kk = 1:(n_par.nk)\n        for bb = 1:(n_par.nb)\n\n            runindex = runindex + 1\n\n            ωLL = ω_left_b_a[bb, kk, hh] .* ω_left_k_a[bb, kk, hh]\n\n            ωRL = ω_right_b_a[bb, kk, hh] .* ω_left_k_a[bb, kk, hh]\n\n            ωLR = ω_left_b_a[bb, kk, hh] .* ω_right_k_a[bb, kk, hh]\n\n            ωRR = ω_right_b_a[bb, kk, hh] .* ω_right_k_a[bb, kk, hh]","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Thereafter, we calculate the linear index associated with the asset policy choice j_adj.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"            j_adj = j_b_a[bb, kk, hh] .+ (j_k_a[bb, kk, hh] - 1) .* n_par.nb","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Still inside the loop, for each future productivity realization (indicated by the index jj), we then calculate the respective gamma^i_(b k h) rightarrow (b k h), save them in weight_adj. These future productivity realizations are transitioned to from todays productivity hh with the probability pp. We also save the index the policy functions point to in targetindex_adj, and save the run index as an indicator of the current position in the state space in startindex_adj.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"            for jj = 1:(n_par.nh)\n                pp = Π[hh, jj]\n\n                bb = blockindex[jj]\n\n                weight_adj[1, jj, runindex] = ωLL .* pp\n                weight_adj[2, jj, runindex] = ωRL .* pp\n                weight_adj[3, jj, runindex] = ωLR .* pp\n                weight_adj[4, jj, runindex] = ωRR .* pp\n\n                targetindex_adj[1, jj, runindex] = j_adj .+ bb\n                targetindex_adj[2, jj, runindex] = j_adj + 1 .+ bb\n                targetindex_adj[3, jj, runindex] = j_adj + n_par.nb .+ bb\n                targetindex_adj[4, jj, runindex] = j_adj + n_par.nb + 1 .+ bb\n\n                startindex_adj[1, jj, runindex] = runindex\n                startindex_adj[2, jj, runindex] = runindex\n                startindex_adj[3, jj, runindex] = runindex\n                startindex_adj[4, jj, runindex] = runindex\n            end\n        end\n    end\nend","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Each of the three matrices has three dimensions, as already touched upon above. The first corresponds to the four potential realizations of the gamble over the asset grid points, the second dimension corresponds to potential different realizations of the productivity state, and the last dimension to the current position in the state space.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The non-adjustment case is identical to the above-illustrated case but features only two potential realizations of the gambles over the grid points. In the non-adjustment case, households only choose their optimal savings in the liquid asset, which can only be between two grid points.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Before returning the arrays of the two cases, we flatten them","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"S_a = startindex_adj[:]\nT_a = targetindex_adj[:]\nW_a = weight_adj[:]\n\nS_n = startindex_non[:]\nT_n = targetindex_non[:]\nW_n = weight_non[:]","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"As a result, we obtain matrices representing the starting positions, target positions, and the associated weights. We then use the Julia function sparse to create the transition matrix. It creates the matrix such that Γ_i[Start_Index[k], Target_Index[k]] = Weight[k], where k denotes the linear index over the flattened arrays above. This matrix has dimensions of nb times nk times nh rows by nb times nk times nh columns. It assigns the saved weights to transitions from the start index today (rows) to the target index tomorrow (columns).","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Γ_a = sparse(\n    S_a,\n    T_a,\n    W_a,\n    n_par.nb * n_par.nk * n_par.nh,\n    n_par.nb * n_par.nk * n_par.nh,\n)\n\nΓ_n = sparse(\n    S_n,\n    T_n,\n    W_n,\n    n_par.nb * n_par.nk * n_par.nh,\n    n_par.nb * n_par.nk * n_par.nh,\n)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Finally, we weight the different transition matrices by their respective probability of occurrence:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Γ = m_par.λ .* Γ_a .+ (1.0 .- m_par.λ) .* Γ_n","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Next, we find the (real) left-unit eigenvector using the eigsolve function:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"aux = real.(eigsolve(Γ', distr_guess[:], 1)[2][1])","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"We then normalize the obtained distribution to ensure it corresponds to a valid distribution:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"distr = reshape(aux ./ sum(aux), (n_par.nb, n_par.nk, n_par.nh))","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Finally, we use the obtained distribution to aggregate the household side by multiplying today's distribution with the meshes of the liquid and illiquid savings.","category":"page"},{"location":"Computational Notes/#Law-of-Motion-of-the-Distribution-along-Equilibrium-Dynamics","page":"Computational Notes","title":"Law of Motion of the Distribution along Equilibrium Dynamics","text":"","category":"section"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Next, we illustrate how to find the transition matrix Gamma_t away from the steady state. The key difference from the steady state case is that the transition matrix is no longer time-invariant. This is because the policy functions change as a function of the current position in the state-space. With the policy functions at the current realization of the state variables at hand, the calculation of the transition matrix remains the same, and we can find the next period's distribution by matrix multiplication as in the law of motion of the distribution (see eq. (LOM distribution)). However, since we solve the economy using classical perturbation methods, it is impractical to include a large matrix multiplication, as the multiplication must be repeated each time we take derivatives of the entire system.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"When finding the new distribution in the file BASEforHANK.PerturbationSolution.Fsys() within the function Fsys, we employ a slightly different approach. Using the previous period's distribution Theta_t, we directly compute the next period's distribution Theta_t+1 in the function DirectTransition. Intuitively, we calculate the transition probabilities gamma^i_(b k h) rightarrow (b k h) and directly distribute the current mass of households at each point in the state space to the next period's distribution. We can perform both operations in a single loop iteration, as today's mass, the transition probability, and the future location in the distribution are all functions of today's position in the state space.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The implementation is illustrated below. First, we calculate the indeces and (right-hand-side) weights associated with the policy functions using MakeWeightsLight, which is an optimized version of the MakeWeights function. Moreover, we again use the blockindex to be able to use linear indexing.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"j_k_a, ω_right_k_a = MakeWeightsLight(k_a_star, n_par.grid_k)\nj_b_a, ω_right_b_a = MakeWeightsLight(b_a_star, n_par.grid_b)\nj_b_n, ω_right_b_n = MakeWeightsLight(b_n_star, n_par.grid_b)\n\nblockindex = (0:(n_par.nh - 1)) * n_par.nk * n_par.nb","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Second, we iterate over the entire state space today to calculate the next period's distribution. This is done in several substeps:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Extract the current mass of households dd and calculate the (linear) indices that the policy functions for assets map to (j_adj and j_non).\nCalculate the mass of households that transition to asset grid points in the next period for both the adjustment and non-adjustment cases.\nApply the transition probability for productivity and distribute households according to the policy functions and the transition matrix of productivity over tomorrow's state space.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The first step uses the indices calculated above and is, with exception to the extraction of the distribution, identical to the approach in MakeTransition:","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"dd = distr[bb, kk, hh]\n\nj_adj = (j_b_a[bb, kk, hh] .+ (j_k_a[bb, kk, hh] .- 1) .* n_par.nb)\nj_non = (j_b_n[bb, kk, hh] .+ (kk - 1) .* n_par.nb)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The second step involves using the weights and the current mass of households at each point in the state space to distribute the mass according to the policy function weights. Additionally, we account for the probability of each policy occurring by multiplying by 1-λ for the non-adjustment case and λ for the adjustment case.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"All variables d_ in the code below indicate the mass of households that transition from today's state space to grid points (and their respective neighbors) in tomorrow's state space, as indicated by j_adj and j_non. We first calculate this mass for the liquid assets of non-adjusters.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"ω = ω_right_b_n[bb, kk, hh]\nd_L_n = (1.0 .- λ) .* (dd .* (1.0 .- ω))\nd_R_n = (1.0 .- λ) .* (dd .* ω)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"Then we caculate the the mass of households transitioning to the four grid-points in the case of adjustment.","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"ω = ω_right_k_a[bb, kk, hh]\nd_L_k_a = λ .* (dd .* (1.0 .- ω))\nd_R_k_a = λ .* (dd .* ω)\n\nω = ω_right_b_a[bb, kk, hh]\nd_LL_a = (d_L_k_a .* (1.0 .- ω))\nd_LR_a = (d_L_k_a .* ω)\nd_RL_a = (d_R_k_a .* (1.0 .- ω))\nd_RR_a = (d_R_k_a .* ω)","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"In the final step, for each productivity state, we need to weight the masses by the transition probability of the productivity state (pp) and add them to empty container of the next period's distribution (dPrime) at the indices indicated by their policies and the respective productivity state (j_a and j_n):","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"for hh_prime = 1:(n_par.nh)\n    pp = Π[hh, hh_prime]\n\n    j_a = j_adj .+ blockindex[hh_prime]\n    j_n = j_non .+ blockindex[hh_prime]\n\n    dPrime[j_a] += pp .* d_LL_a\n    dPrime[j_a + 1] += pp .* d_LR_a\n    dPrime[j_a + n_par.nb] += pp .* d_RL_a\n    dPrime[j_a + n_par.nb + 1] += pp .* d_RR_a\n    dPrime[j_n] += pp .* d_L_n\n    dPrime[j_n + 1] += pp .* d_R_n\nend","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"The last step differs only from the generation of the transition matrix Gamma_t in MakeTransition in that it directly multiplies the mass of the distribution to the respective transition probabilities gamma^i_(b k h) rightarrow (b k h).","category":"page"},{"location":"Computational Notes/","page":"Computational Notes","title":"Computational Notes","text":"When iterating over the entire state space in the loop, we calculate the masses of households that transition from today's state space to tomorrow's state space, correctly weighted to account for their policy functions, the ability to adjust illiquid assets, and productivity realizations. By adding these masses to the initially empty dPrime array, we aggregate the masses of households that transition into the same point in the next period's distribution, even if they originate from different points in today's state space.","category":"page"},{"location":"examples/baseline/#Baseline-Example","page":"Baseline example","title":"Baseline Example","text":"","category":"section"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"This baseline example comes closest to the original paper (Bayer, Born, and Luetticke (2024, AER)). We provide two mainboards that accompany this example in the examples/baseline/ folder:","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"main.jl which showcases the toolbox including the estimation part and\nmain_noestim.jl which showcases the toolbox without the estimation part.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"In the following, we focus on main.jl.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Please refer to the main page of the documentation for general information on how to set up the toolbox.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"The provided main.jl shows how a typical estimation proceeds in three main steps. First, we solve the steady state of the model. Then, the algorithm performs a two-step dimensionality reduction as described in the accompanying paper (Bayer, Born, and Luetticke (2024, AER)). The second step of this reduction uses the prior information to obtain and approximate factor representation from an initial, not further reduced solution. Secondly, we compute the linearized dynamics of the reduced model around the steady state. Thirdly, we construct the likelihood of the model parameters given the data and use Bayesian methods to estimate them. More details on the three steps are provided below and in the respective sections of the documentation.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Next, we move through main.jl step by step.","category":"page"},{"location":"examples/baseline/#Setup-of-the-model","page":"Baseline example","title":"Setup of the model","text":"","category":"section"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"To define the aggregate part of the baseline example's model, we included the aggregate model block in examples/baseline/Model/.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Firstly, we define the aggregate variables in input_aggregate_names.jl. In particular, we define a (symbolic) list of shocks as shock_names, a (string) list of state variables as state_names, and a (string) list of control variables as control_names. We also define a (string) list of distributional statistics that are just controls as distr_names.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Recall: These are only the aggregate variables so that the distribution (state) and the marginal utilities/value functions (controls) are not included here.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Importantly, some variables have to exist (with exactly these names and definitions). The reason for that is that these variables play a crucial role in the household problem, see also the in-detail explanation of the HouseholdProblem.md.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"The steady state of the aggregate variables is defined in input_aggregate_steady_state.mod. Notably, there are a few exceptions which are provided using a different syntax. The reason for this is that these variables affect the household problem. Therefore, they are computed in compute_args_hh_prob_ss based on the user-provided functions in input_functions.jl as well as assumptions of the household problem and some further assumptions. If the user provides these steady state values also in input_aggregate_steady_state.mod, these will be compared to the values computed in compute_args_hh_prob_ss and a warning will be issued if they differ.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"The file input_parameters.jl contains three structures to provide model parameters, numerical parameters, and estimation settings.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Model parameters that only affect the aggregate dynamics can be freely adjusted. Parameters that (also) affect the household problem have to exist (with exactly these names and definitions). The reason for that is that these variables play a crucial role in the household problem, see also the in-detail explanation of the HouseholdProblem.md. Each element of the struct ModelParameters consists of a parameter name, its value, its ascii name, its long name, its LaTeX name, its prior (please see the Distributions.jl-package for available options), and a Boolean whether the parameter should be estimated or not.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"The model parameters need to be set in your mainboard.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"The struct NumericalParameters numerical parameters contain several types of parameters such as grids and meshes, variable types etc.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"The numerical parameters are automatically set in call_find_steadystate(), based on their default values in input_parameters.jl, where the user can modify them.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Finally, the file input_aggregate_model.jl contains the aggregate model equations. The user has to provide the equations in the form of","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"F[equation number] = (lhs) - (rhs)","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"where the equation number is based on an variable-specific index, to be explained later.","category":"page"},{"location":"examples/baseline/#Header","page":"Baseline example","title":"Header","text":"","category":"section"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"In this section, we set up the paths and pre-process the user's model inputs for the current example in the block","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"include(paths[\"src\"] * \"/Preprocessor/PreprocessInputs.jl\");","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Notably, this already pre-processes the aggregate model equations as well as the steady state file that are located in the folder examples/baseline/Model/ and produces the generated functions in the folder bld/baseline/Preprocessor/generated_fcns/. For more details on the pre-processing, see [...].","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Importantly, this pre-processing has to be performed before loading the BASEforHANK module defined in BASEforHANK.jl, that is then loaded via","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"include(\"BASEforHANK.jl\")\nusing .BASEforHANK","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"BASEforHANK.jl is the key module file as it loads in the code base, sets up structures, and exports a number of functions and macros.","category":"page"},{"location":"examples/baseline/#Steady-state-and-first-dimensionality-reduction","page":"Baseline example","title":"Steady state and first dimensionality reduction","text":"","category":"section"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"The command","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"sr_full = compute_steadystate(m_par)","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"calls the functions BASEforHANK.find_steadystate() and BASEforHANK.prepare_linearization() and saves their returns in an instance sr_full of the struct SteadyResults. In exact, sr_full contains vectors of the steady-state variables (together with index-vectors to reference them by name) and the steady-state distribution of income and assets. It also contains the marginal value functions and the distributions as well as their first-stage model reduction counterparts (obtained through DCTs).","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"tip: Tip\nsr_full may be saved to the local file system by calling@save \"Output/Saves/steadystate.jld2\" sr_fulland can be loaded for a future session with@load \"Output/Saves/steadystate.jld2\" sr_full","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"More details can be found in the section \"Steady State\".","category":"page"},{"location":"examples/baseline/#Linearize-full-model","page":"Baseline example","title":"Linearize full model","text":"","category":"section"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"After computing the steady state and saving it in the SteadyResults-struct named sr_full,","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"lr_full = linearize_full_model(sr_full, m_par)","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"computes the linear dynamics of the \"full\" model, i.e., using the first-stage model reduction, around the steady state (in the background, this calls BASEforHANK.PerturbationSolution.LinearSolution()) and saves a state-space representation in the instance lr_full of the struct LinearResults (see linearize_full_model()).","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Linearization of the full model takes a few seconds. The resulting state space is relatively large, because the copula and the value functions are treated fully flexible in this first step. As a result, also computing the first-order dynamics of this model takes a few seconds as well.","category":"page"},{"location":"examples/baseline/#Model-reduction","page":"Baseline example","title":"Model reduction","text":"","category":"section"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"This large state-space representation can, however, be reduced substantially using an approximate factor representation. For this purpose, we run","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"sr_reduc    = model_reduction(sr_full, lr_full, m_par)","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"which calculates the unconditional covariance matrix of all state and control variables and rewrites the coefficients of the value functions and the copula as linear combinations of some underlying factors. Only those factors that have eigenvalues above the precision predefined in sr_full.n_par.compress_critC (controls, i.e., marginal value functions) and sr_full.n_par.compress_critS (states, i.e., the copula) are retained.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"warning: Warning\nAfter model reduction, sr_reduc.indexes_r contains the indexes that map correctly into the states/controls used in LOMstate and State2Control.","category":"page"},{"location":"examples/baseline/#Model-solution-after-a-parameter-change-/-after-reduction","page":"Baseline example","title":"Model solution after a parameter change / after reduction","text":"","category":"section"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"This smaller model (or any model after a parameter change that doesn't affect the steady state) can be solved quickly using a factorization result from Bayer, Born, and Luetticke (2024, AER) running","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"lr_reduc    = update_model(sr_reduc, lr_full, m_par)","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"In the background, this calls BASEforHANK.PerturbationSolution.LinearSolution_reduced_system(), which only updates the Jacobian entries that regard the aggregate model. (Note that both BASEforHANK.PerturbationSolution.LinearSolution() and BASEforHANK.PerturbationSolution.LinearSolution_reduced_system() call BASEforHANK.PerturbationSolution.SolveDiffEq() to obtain a solution to the linearized difference equation.)","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"This model update step takes about 100ms on a standard computer for the medium size resolution used as a default in the example code.","category":"page"},{"location":"examples/baseline/#Estimation-of-model-parameters","page":"Baseline example","title":"Estimation of model parameters","text":"","category":"section"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Having obtained SteadyResults sr_reduc and LinearResults lr_reduc, the command","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"er_mode = find_mode(sr_reduc, lr_reduc, m_par, e_set)","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"computes the mode of the likelihood, i.e., the parameter vector that maximizes the probability of observing the data given the model, and saves the results in er_mode, an instance of struct EstimResults (see BASEforHANK.Estimation.mode_finding()). We use the Kalman filter to compute the likelihood, and the package Optim for optimization. Settings for the estimation can be adjusted in the struct EstimationSettings.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"warning: Warning\nBy default, the flag estimate_model in the struct EstimationSettings is set to false. Depending on the computing power available, finding the mode of the likelihood can take several hours to run through. The mode finder might also seem frozen after finishing the optimization but the computation of the Hessian for the large model is involved and can take a long time for the large model. For instructional purposes, we therefore set e_set.compute_hessian = false by default and load the Hessian from a save file. For a proper estimation, this has to be set to true. We also save an intermediate step before computing the Hessian in case you are only interested in the mode itself.","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"Lastly,","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"sample_posterior(sr_reduc, lr_reduc, er_mode, m_par, e_set)","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"uses a Markov Chain Monte Carlo method to trace out the posterior probabilites of the estimated parameters. The final estimates (and further results) are saved in a file with the name given by the field save_posterior_file in the struct EstimationSettings (instantiated in e_set).","category":"page"},{"location":"examples/baseline/","page":"Baseline example","title":"Baseline example","text":"note: Note\nThe module BASEforHANK creates the estimation settings e_set in its main script (when it is initialized), so changes to the struct EstimationSettings are only effective before using BASEforHANK. Make sure that all file paths specified in EstimationSettings are correct relative to your script's position.","category":"page"},{"location":"Estimation/#Estimation-of-parameters","page":"Estimation","title":"Estimation of parameters","text":"","category":"section"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"note: Note\nMost of the code of this section is in the submodule Estimation","category":"page"},{"location":"Estimation/#Settings","page":"Estimation","title":"Settings","text":"","category":"section"},{"location":"Estimation/#BASEforHANK.Parsing.EstimationSettings","page":"Estimation","title":"BASEforHANK.Parsing.EstimationSettings","text":"EstimationSettings()\n\nCollect settings for the estimation of the model parameters in a struct.\n\nUse package Parameters to provide initial values. Input and output file names are stored in the fields mode_start_file, data_file, save_mode_file and save_posterior_file.\n\n\n\n\n\n","category":"type"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"The estimation settings (globally instantiated as e_set in BASEforHANK.jl) manage the following areas of the estimation:","category":"page"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"the match between data and model: data_file is a path to a .csv-file   that contains quarterly observations of several variables (in columns), named in   observed_vars_input. Missing data is denoted by NaN. If some column-names do not align with the model   variables, data_rename is used. Level variables that should correspond to growth   rates in the data can be selected in growth_rate_select. Measurement errors   will be added for observables in meas_error_input\nestimation of variances: shock_names contain the aggregate shocks in the model,   whose variances are estimated. me_treatment defines how measurement errors   are treated: for :fixed, their variances are fixed by the data-variance, otherwise   they are estimated either with :bounded uniform priors, or :unbounded priors (see BASEforHANK.Estimation.measurement_error()). For the latter case, the priors are set in   meas_error_distr\nnumerical parameters: the maximum number of iterations to find the mode of the   likelihood (see BASEforHANK.Estimation.mode_finding()) is set in max_iter_mode. ndraws, burnin   and mhscale are parameters for the Random-Walk Metropolis Hastings algorithm (see BASEforHANK.rwmh())\nestimation flags: whether to estimate the model is set in estimate_model. compute_hessian determines whether the Hessian is computed after mode finding or set to an identity matrix (see BASEforHANK.Estimation.mode_finding()). multi_chain_init sets whether multiple chains in the RWMH (see BASEforHANK.Estimation.multi_chain_init() and BASEforHANK.rwmh()) are started from an overdispersed posterior mode. All flags are set to false by default.","category":"page"},{"location":"Estimation/#Mode-finding","page":"Estimation","title":"Mode finding","text":"","category":"section"},{"location":"Estimation/#BASEforHANK.Estimation.mode_finding","page":"Estimation","title":"BASEforHANK.Estimation.mode_finding","text":"mode_finding(XSSaggr, A, B, indexes, indexes_aggr, distrSS, compressionIndexes, m_par, n_par, e_set)\n\nGiven definition of observed variables and their transformation (level or growth rate) from e_set, load the data, construct the observation equation, and maximize likeli() (the log-likelihood) using the package Optim.\n\nSave estimation results to e_set.save_mode_file.\n\nReturns\n\npar_final: parameter vector that maximizes the likelihood\nhessian_final: Hessian of the log-likelihood at par_final\nposterior_mode: log-likelihood at par_final\nmeas_error,meas_error_std: returns from measurement_error()\nparnames: names of estimated parameters (including measurement error variances)\nData,Data_missing: data from e_set.data_file; marker for missing data\nH_sel: selector matrix for states/controls that are observed\npriors: priors of parameters (including measurement error variances)\nsmoother_output: output from the Kalman smoother\n\n\n\n\n\n","category":"function"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"The main computations are the construction of the likelihood of the model parameters and its maximization. We get the model parameters that are to be estimated, together with their priors, from m_par (in addition to measurement error variances, see Settings).","category":"page"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"There is also the option to provide a file with initial guesses of parameters for the mode finding, which might have computational advantages compared to the priors from m_par. In the baseline example we provide these initial guesses through the txt-file named par_final_dict. The first if-condition in the function BASEforHANK.find_mode() guarantees that if the file is not provided, priors from m_par will be used for mode finding. However, if the extra file is provided, the contained dictionary therein is loaded and the specified guesses are assigned to the starting values. Loading it as a dictionary guarantees that the assignment is order-insensitive and thus robust to changes in the individual selection of which parameters are to be estimated. Note that it is also possible to only specify values for a part of the to-be-estimated parameters and in this case the missing starting values will be replaced by the mode of priors from m_par.","category":"page"},{"location":"Estimation/#The-likelihood-function","page":"Estimation","title":"The likelihood function","text":"","category":"section"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"The function BASEforHANK.Estimation.likeli() computes the log-likelihood of the model parameters par in the following steps:","category":"page"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"call BASEforHANK.PerturbationSolution.LinearSolution_reduced_system() to derive the linear state-space representation of the model given par.  Differently from BASEforHANK.PerturbationSolution.LinearSolution(), differentiate only the system of aggregate equilibrium  conditions with respect to aggregate variables, i.e. BASEforHANK.PerturbationSolution.Fsys_agg(). This is sufficient,  as the estimated parameters do not enter in the heterogeneous agent part of the equilibrium system [BBL].  Then, update the derivatives A and B of the full model for aggregate variables and conditions,  and compute the observation and state transition equations as in BASEforHANK.PerturbationSolution.LinearSolution()\ndelete rows of the observation equation that correspond to unobserved controls  (the selector matrix H_sel is constructed in BASEforHANK.Estimation.mode_finding()). Then, feed  the linear state-space system, the data, and the variances of the structural and  measurement shocks, into the Kalman filter (see BASEforHANK.Estimation.kalman_filter()), which computes  the log-likelihood","category":"page"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"We find the maximizer of the likelihood function, as well as its Hessian at the maximum, with the package Optim. Note that in order to obtain the Hessian, you need to set e_set.compute_hessian = true.","category":"page"},{"location":"Estimation/#Called-functions","page":"Estimation","title":"Called functions","text":"","category":"section"},{"location":"Estimation/#BASEforHANK.Estimation.likeli","page":"Estimation","title":"BASEforHANK.Estimation.likeli","text":"likeli(par, Data, Data_missing, H_sel, priors, meas_error, meas_error_std, sr, lr, m_par, e_set; smoother=false)\n\nCompute the likelihood of Data, given model-parameters par and prior priors (maximize to find MLE of par).\n\nSolve model with LinearSolution_reduced_system(), compute likelihood with kalman_filter() or with kalman_filter_smoother() (if smoother==True).\n\nReturns\n\nif smoother==False:\n\nlog_like,prior_like,post_like,alarm: log-likelihoods (post is the sum of prior and computed likelihood); alarm indicates error when solving model with LinearSolution_reduced_system, sets log-likelihood to -9.e15\n\nif smoother==True:\n\nsmoother_output: returns from kalman_filter_smoother()\n\n\n\n\n\nlikeli(par, sr, lr, er, m_par, e_set; smoother=false)\n\nCompute the likelihood of er.Data, given model-parameters par and prior er.priors (maximize to find MLE of par).\n\nSolve model with LinearSolution_reduced_system(), compute likelihood with kalman_filter() or with kalman_filter_smoother() (if smoother==True).\n\nReturns\n\nif smoother==False:\n\nlog_like,prior_like,post_like,alarm: log-likelihoods (post is the sum of prior and computed likelihood); alarm indicates error when solving model with LinearSolution_reduced_system, sets log-likelihood to -9.e15\n\nif smoother==True:\n\nsmoother_output: returns from kalman_filter_smoother()\nState2Control,LOM: state-to-control and state transition matrizzes\n\n\n\n\n\n","category":"function"},{"location":"Estimation/#BASEforHANK.PerturbationSolution.LinearSolution_reduced_system","page":"Estimation","title":"BASEforHANK.PerturbationSolution.LinearSolution_reduced_system","text":"LinearSolution_reduced_system(sr, m_par, A, B,;allow_approx_sol)\n\nCalculate the linearized solution to the non-linear difference equations defined by function Fsys, while only differentiating with respect to the aggregate part of the model, Fsys_agg().\n\nThe partials of the Jacobian belonging to the heterogeneous agent part of the model are taken from the full-model derivatives provided as arguments, A and B (computed by LinearSolution()).\n\nArguments\n\nsr: steady-state structure (variable values, indexes, numerical parameters, ...)\nA,B: derivative of Fsys() with respect to arguments X [B] and   XPrime [A]\nm_par: model parameters\nallow_approx_sol: if true, the function will attempt to solve the linearized model   even if the system is indeterminate (shifting the critical eigenvalues)\n\nReturns\n\nas in LinearSolution()\n\n\n\n\n\n","category":"function"},{"location":"Estimation/#BASEforHANK.Estimation.kalman_filter","page":"Estimation","title":"BASEforHANK.Estimation.kalman_filter","text":"kalman_filter(H,LOM,Data,D_miss,SCov,MCov,e_set)\n\nCompute likelihood of Data, applying the Kalman filter to the state-space represenation (H,LOM) of the model.\n\nArguments\n\nH::Array{Float64,2}: observation equation\nLOM::Array{Float64,2}: law of motion for states\nData::Array{Union{Missing,Float64},2},D_miss::BitArray{2}: data (time times variable); marker for missing data\nSCov::Array{Float64,2}: covariance of structural shocks\nMCov::Array{Float64,2}: covariance of measurement error\n\nReturns\n\nlog-likelihood\n\n\n\n\n\n","category":"function"},{"location":"Estimation/#BASEforHANK.Estimation.measurement_error","page":"Estimation","title":"BASEforHANK.Estimation.measurement_error","text":"measurement_error(Data,observed_vars,e_set)\n\nBuild measurement error.\n\nArguments\n\nData: matrix of observables [nobs * nvar]\nobserved_vars: vector of observed variable names [nvar * 1]\ne_set::EstimationSettings\n\nReturns\n\nmeas_error: ordered dictionary of measurement errors linked to observables\nmeas_error_prior: corresponding priors for measurement errors\nmeas_error_std: standard deviations of observables with measurement error\n\n\n\n\n\n","category":"function"},{"location":"Estimation/#Bayesian-estimation","page":"Estimation","title":"Bayesian estimation","text":"","category":"section"},{"location":"Estimation/#BASEforHANK.sample_posterior","page":"Estimation","title":"BASEforHANK.sample_posterior","text":"mcmc_estimation(sr, lr, er, m_par, e_set)\n\nSample posterior of parameter vector with rwmh(), take sample mean as parameter estimate, and save all results in file.\n\nArguments\n\nsr::SteadyResults: Output of call_prepare_linearization()\nlr::LinearResults: Output of linearize_full_model()\ner::EstimResults: Output of find_mode()\nm_par::ModelParameters\ne_set::EstimationSettings\n\nReturns\n\nsr::SteadyResults: Updated SteadyResults\nlr::LinearResults: Updated LinearResults\ner::EstimResults: Updated EstimResults\nm_par::ModelParameters: Updated ModelParameters\ndraws_raw::Array{Float64,2}: Raw draws from the posterior\nposterior::Array{Float64,1}: Posterior\naccept_rate::Float64: Acceptance rate\npar_final::Array{Float64,1}: Mode of the posterior\nhessian_sym::Symmetric{Float64,Array{Float64,2}}: Hessian of the posterior\nsmoother_output::Array{Float64,2}: Smoother output\n\n\n\n\n\n","category":"function"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"We use a Monte Carlo Markov Chain method, specifically the Random-Walk Metropolis Hastings (BASEforHANK.Estimation.rwmh()) algorithm, to sample from the posterior probability distribution of the parameter vector. The acceptance rate of the algorithm can be adjusted via setting EstimationSettings.mhscale. To obtain the posterior likelihood of each draw, we call BASEforHANK.Estimation.likeli(), which evaluates the priors at par (BASEforHANK.Estimation.prioreval()) and returns the log-posterior as a sum of the log-prior and the log-likelihood.","category":"page"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"Given the draws from the posterior, we can analyze the probabilities of the parameters using the package MCMCChains. We take the average over the draws as our Bayesian estimate of the parameter vector, par_final. To obtain an estimate of the underlying state over the data sample period, we call BASEforHANK.Estimation.likeli() with par_final and keyword smoother=true (this calls the Kalman smoother BASEforHANK.Estimation.kalman_filter_smoother()). The result is stored in smoother_output, and saved with the other results in e_set.save_posterior_file.","category":"page"},{"location":"Estimation/#Called-functions-2","page":"Estimation","title":"Called functions","text":"","category":"section"},{"location":"Estimation/#BASEforHANK.Estimation.rwmh","page":"Estimation","title":"BASEforHANK.Estimation.rwmh","text":"rwmh(xhat, Σ, sr, lr, er, m_par, e_set)\n\nSample the posterior of the parameter vector using the Random-Walk Metropolis Hastings algorithm.\n\nReturns\n\ndraws::Array{Float64,2}: e_set.ndraws + e_set.burnin sampled parameter vectors (row vectors)\nposterior: vector of posteriors for the respective draws\naccept_rate: acceptance rate\n\n\n\n\n\n","category":"function"},{"location":"Estimation/#BASEforHANK.Estimation.multi_chain_init","page":"Estimation","title":"BASEforHANK.Estimation.multi_chain_init","text":"multi_chain_init(xhat, Σ, sr, lr, er, m_par, e_set)\n\nDraw overdispersed initial values for multi-chain RWMH.\n\nReturns\n\ninit_draw: overdispersed starting value for chain\ninit_draw: Bool variable indicating whether search was succesful\n\n\n\n\n\n","category":"function"},{"location":"Estimation/#BASEforHANK.Estimation.prioreval","page":"Estimation","title":"BASEforHANK.Estimation.prioreval","text":"prioreval(par,priors)\n\nEvaluate prior PDF at the parameters given in par.\n\nArguments\n\npar: vector of parameters [npar*1]\npriors: vector of prior distributions [npar*1]\n\nReturns\n\nlog_priorval: log prior density [scalar]\nalarm: indicator that is 1 if there is a violation of the prior bounds [scalar]\n\n\n\n\n\n","category":"function"},{"location":"Estimation/#BASEforHANK.Estimation.kalman_filter_smoother","page":"Estimation","title":"BASEforHANK.Estimation.kalman_filter_smoother","text":"kalman_filter_smoother(H, LOM, Data, D_nomiss, SCov, MCov, e_set)\n\nCompute likelihood and estimate of underlying states given the full observed Data by applying the Kalman smoother to the state-space representation (H,LOM) of the model.\n\nArguments\n\nH::Array{Float64,2}: observation equation\nLOM::Array{Float64,2}: law of motion for states\nData::Array{Union{Missing,Float64},2},D_nomiss::BitArray{2}: data (time times variable); marker for existent data\nSCov::Array{Float64,2}: covariance of structural shocks\nMCov::Array{Float64,2}: covariance of measurement error\n\nReturns\n\nlog_lik: log-likelihood\nxhat_tgt,xhat_tgT: estimate of underlying states from forward iteration [xhat_tgt] and   backward iteration [xhat_tgT]\nSigma_tgt,Sigma_tgT: estimate of covariance matrices from forward iteration [Sigma_tgt]   and backward iteration [Sigma_tgT]\ns,m: smoothed structural shocks [s] and measurement errors [m]\n\n\n\n\n\n","category":"function"},{"location":"Estimation/#BASEforHANK.find_mode","page":"Estimation","title":"BASEforHANK.find_mode","text":"find_mode(sr, lr, m_par, e_set)\n\nFind parameter that maximizes likelihood of data given linearized model lr.\n\nArguments\n\nsr::SteadyResults: Output of call_prepare_linearization()\nlr::LinearResults: Output of linearize_full_model()\nm_par::ModelParameters\ne_set::EstimationSettings\n\nReturns\n\nEstimResults, containing all returns of mode_finding()\nposterior_mode::Array{Float64,1}: Mode of the posterior\nsmoother_output::Array{Float64,2}: Smoother output\nsr::SteadyResults: Updated SteadyResults\nlr::LinearResults: Updated LinearResults\nm_par::ModelParameters: Updated ModelParameters\n\n\n\n\n\n","category":"function"},{"location":"Estimation/","page":"Estimation","title":"Estimation","text":"[BBL]: For details, see the paper Shocks, Frictions, and Inequality in US Business Cycles, American Economic Review, forthcoming.","category":"page"},{"location":"#BASEforHANK.jl-Documentation","page":"Home","title":"BASEforHANK.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This manual documents the Julia package BASEforHANK, which provides a toolbox for the Bayesian Solution and Estimation (BASE) of a heterogeneous-agent New-Keynesian (HANK) model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It comes with examples that showcase how to use the package. Originally, the code accompanied the paper Bayer, Born, and Luetticke (2024, AER). Note that the toolbox is not a 1-for-1 replication package for the linked paper. In particular, the preset resolution is smaller.","category":"page"},{"location":"#First-steps","page":"Home","title":"First steps","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We recommend to use Julia for VSCode IDE as a front-end to Julia. To get started with the toolbox, simply download or clone the folder, e.g. via git clone and set your cd to the project directory. Then start the Julia REPL and type ] so that you can call","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.10) pkg> activate .\n\n(BASEtoolbox) pkg> instantiate","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install all needed packages. For more on Julia environments, see Pkg.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nBefore you activate the environment, make sure that you are in the main directory, in which the Project.toml file is located. In case you accidentally activated the environment in a subfolder, empty .toml files will be created that you need to delete before proceeding in the correct folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have tested the module on Julia Version 1.10.3 (macOS, arm64-apple-darwin22.4.0), Version 1.10.4 (Windows, x86_64-w64-mingw32), and Version 1.10.5 (Linux, x86_64-linux-gnu). You can find out which version you are using by calling versioninfo() in the Julia REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use a different editor, make sure that the environment is correctly set, as otherwise the instantiated packages might not be found.","category":"page"},{"location":"#Toolbox-folder-structure","page":"Home","title":"Toolbox folder structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the following, we call the root directory of the repository BASEtoolbox.jl (which is the directory containing, for instance, Project.toml). The folder structure is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"src/: Contains the source code of the toolbox, that is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the main module file BASEforHANK.jl,\nthe submodules in the folder SubModules/,\nand the pre-processing functions in the folder Preprocessor/.","category":"page"},{"location":"","page":"Home","title":"Home","text":"examples/: Contains the examples that showcase the toolbox. For each example, there is a subfolder in examples/ that contains the main file to run the example as well as all relevant files for the example. The baseline example that showcases most functions of the toolbox is given by examples/baseline/main.jl. This is strictly required as it serves as the baseline for testing and documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"bld: Contains the generated files (after generating them). The folder is not part of the repository, but is created when running (certain parts of) the toolbox. That is, the folder contains:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the generated files from the examples as subfolders of bld/.","category":"page"},{"location":"","page":"Home","title":"Home","text":"docs/: Contains the documentation of the toolbox, that is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the source code in src/,\nand the generated documentation in build/.","category":"page"},{"location":"#Building-the-documentation","page":"Home","title":"Building the documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can build the documentation locally by starting a new Julia REPL in the root directory of the repository, activating the environment, and running the following command: include(\"docs/make.jl\"). You can access the documentation, once it is built locally, via running python3 -m http.server --directory docs/build/. If you then open your browser at http://localhost:8000, the documentation should render properly. Beyond that, the documentation is hosted via GitHub Pages and can be accessed here.","category":"page"},{"location":"#Setting-up-your-model","page":"Home","title":"Setting up your model","text":"","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to add a new model, the recommended way is to start by copying one of the provided examples into a new folder in examples/. This way, you can make sure that all necessary files are present and that the toolbox can be run without any issues.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[to do: add more details here]","category":"page"},{"location":"#Special-features","page":"Home","title":"Special features","text":"","category":"section"},{"location":"#Multiple-economies-or-sectors","page":"Home","title":"Multiple economies or sectors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The structure of the problem at hand allows for multiple economies or sectors in the aggregate model part as it would be nothing else than stating additional equations for each of them. To simplify writing up such models, the preprocessor allows using a certain syntax to mark the equations that would need to be repeated or copied for each economy and numbered accordingly. Instead, the preprocessor automatically copies marked equations. Because many ASCII characters are reserved for other purposes, the syntax uses the ? symbol.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The HANK economy is considered to be economy 1, not receiving an additional number. Any repeated equation will then get an additional number, starting with 2. The preprocessor will then automatically replace the ? symbol with the respective number and will repeat the equation accordingly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"E.g., the following two code snippets from input_aggregate_model.mod are equivalent for the preprocessor:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# TFP HANK economy\nF[indexes.Z]    = (log(ZPrime)) - (m_par.ρ_Z * log(Z))\n\n# TFP economy 2\nF[indexes.Z2]   = (log(Z2Prime)) - (m_par.ρ_Z * log(Z2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"# TFP HANK and all other economies\nF[indexes.Z?]    = (log(Z?Prime)) - (m_par.ρ_Z * log(Z?))","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the beginning of the input_aggregate_model.mod file, the user has to specify the number of economies or sectors in their model by the following line:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Setting the number of economies to 2.\n@R?2","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same logic applies when specifying the variable names in input_aggregate_names.jl and input_aggregate_steady_state.mod. Consequently, the syntax can be also used when referring to steady state variables during writing down the model. E.g., Z?SS refers to the steady state value of variable Z for each economy.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to enable convenient syntax highlighting and because the ? character serves other purposes in Julia, .mod files are used instead of .jl files for the user-specified model equations. In VS Code, you can still set the syntax highlighting to Julia for .mod files by clicking on the language mode in the bottom right corner of the editor.","category":"page"},{"location":"#Methods","page":"Home","title":"Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following gives an overview on the methods provided by the toolbox. They naturally build on each other. For a more detailed documentation of each method, including its main functions, see the respective section.","category":"page"},{"location":"#Preprocessing,-parsing,-and-incomes","page":"Home","title":"Preprocessing, parsing, and incomes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[to do: add more details here]","category":"page"},{"location":"#Steady-state-and-preparing-linearization","page":"Home","title":"Steady state and preparing linearization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[to do: add more details here]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given model and parameters, this method computes the steady state of the model, i.e. the stationary equilibrium. It is summarized in a SteadyStateStruct.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Based on the steady state, the linearization of the model is prepared, which involves dimensionality reduction. The output of this step is collected in a struct SteadyResults.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more details, see Steady State.","category":"page"},{"location":"#Linearization-and-model-reduction","page":"Home","title":"Linearization and model reduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[to do: add more details here]","category":"page"},{"location":"#Estimation","page":"Home","title":"Estimation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[to do: add more details here]","category":"page"},{"location":"#Plots-and-statistics","page":"Home","title":"Plots and statistics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[to do: add more details here]","category":"page"}]
}
