# Computation of the steady state and dimensionality reduction
!!! note
    Most of the code of this section is in the submodule `SteadyState` (`src/SubModules/SteadyState/`), except for  `prepare_linearization()`, which is generated by the preprocessor and can be found in `src/Preprocessor/generated_fcns/prepare_linearization_generated.jl`. The preprocessor uses the
    template stored as `src/Preprocessor/template_fcns/prepare_linearization.jl`.

The model features uninsured income shocks ``y`` (by assumption, all workers supply the same
efficiency units of labor [^BBL], so idiosyncratic productivity shocks translate
to income shocks) and two assets, liquid assets (bonds) ``m`` and illiquid assets (capital) ``k``. Entrepreneurs
(last income-state) receive no labor income, but firm profits, while workers additionally
receive labor union profits.

The steady state equilibrium contains, aside from the capital stock, marginal value functions ``V_m`` and ``V_k`` on a three-dimensional grid ``(m \times k \times y)`` and the ergodic joint distribution over these idiosyncratic states.
We do dimensionality reduction [^BL] by applying the Discrete Cosine Transformation to the marginal value functions and approximating the joint distribution with a copula and state-dependent marginals.

The main functions are [`call_find_steadystate()`](@ref) and [`call_prepare_linearization()`](@ref), with [`compute_steadystate()`](@ref) being a wrapper for both of them.

## `compute_steadystate`
```@docs
compute_steadystate
```
Combines steady state computation and preparation of linearization in one function call. It has the same returns as [`call_prepare_linearization()`](@ref).


## `call_find_steadystate`
```@docs
call_find_steadystate
BASEforHANK.SteadyState.find_steadystate
```
The function takes the parameter `struct` `ModelParameters` as input `m_par` (see [Parameters](@ref)).

To find the stationary equilibrium, we proceed in roughly the following steps:

1. Instantiate the parameter `struct` `NumericalParameters` as `n_par` (see [Parameters](@ref)).
   Within the struct, we set the number of income states [`nh`] and use the [`BASEforHANK.Tools.Tauchen()`](@ref)
   method to obtain a grid and a transition matrix of income, given the autocorrelation of the income process [`m_par.ρ_h`].
   Then, include entrepreneurial state.
2. Find equilibrium capital stock (by finding a root of [`BASEforHANK.SteadyState.Kdiff()`](@ref)), where
    the supply of capital by households is calculated in [`BASEforHANK.SteadyState.Ksupply()`](@ref).

    `Ksupply()` uses the Endogenous Grid Method (see [`BASEforHANK.SteadyState.EGM_policyupdate()`](@ref)) to iteratively obtain optimal policies and marginal value functions. The supply of capital by households is then computed based on the eigenvector associated with the unit eigenvalue of the transition matrix that comes out of the households' policies.

    Root finding is performed using Brent's method where the customized algorithm generates initial guesses for value functions and distributions based on previous iterations in the root finding.

This procedure is performed twice: First for a coarse grid (specified in the function) and then for the user-specified grid up to the user-desired precision
[`n_par.ϵ`] \(both defined in the [Parameters](@ref)\).

## `call_prepare_linearization`
```@docs
call_prepare_linearization
BASEforHANK.PerturbationSolution.prepare_linearization
```
We first calculate other equilibrium quantities and produce distributional summary statistics ([`BASEforHANK.Tools.distrSummaries()`](@ref)). Next, we reduce the dimensionality:

1. Find the sparse representation of fluctuations of ``V_m`` and ``V_k`` around the steady state. For this purpose,
    calculate the derivatives of ``V_m`` and ``V_k`` with respect to all prices
    that enter the household problem. Then transform these derivatives using the
    Discrete Cosine Transformation (Julia-package `FFTW`) into polynomial coefficients.
    Calculate the average absolute value of those coefficients and retain those that explain a large
    share of the variance of coefficients (up to `100*(1-n_par.reduc_marginal_value)` percent).
    Add, in the same way, polynomial coefficients that explain  ``V_m`` and ``V_k`` themselves.
    The quality of the latter approximation is controlled by `n_par.reduc_value`.
    The corresponding indices are saved in `compressionIndexes`. This whole step
    is being done in `first_stage_reduction()`.
2. Prepare a node mesh on which the time-varying linear interpolant of the copula
     is defined. The grid in each ``m``, ``k``, and ``y`` dimension is selected
     such that each resulting bin holds approximately the same share of the
     respective aggregate variable.

Lastly, we collect the steady-state values of all model variables in the
vector `XSS` (see [`BASEforHANK.Parsing.@writeXSS`](@ref)). The *state* variables consist of
the marginal distributions over ``m``, ``k`` and ``y`` and the aggregate state variables
(collected in `state_names`). The *control* variables consist of the steady state
marginal value functions (over the full grid) and the aggregate control variables
(collected in `control_names`; these vectors are defined in the main script `BASEforHANK.jl`).

While the steady-state marginal value functions have full dimensionality,
in the vectors that collect *deviations* from steady state (in [`BASEforHANK.PerturbationSolution.Fsys()`](@ref), those are `X` and `XPrime`)
only the coefficients of the most important Chebyshev polynomials are saved.
Additionally, the deviations of the marginal distributions are saved with one entry short of
the grid size, since the marginals are restricted to sum up to 1.
We manage this by creating the `struct` `indexes` (using [`BASEforHANK.Parsing.@make_fn`](@ref)),
that has two fields for each variable: steady state value and deviation.

We also construct the vector `XSSaggr` and the `struct` `indexes_aggr`,
which are similar to the above but only store (and manage) aggregate variables.
This is useful for differentiating only with respect to aggregate variables
in the estimation part (see [`BASEforHANK.PerturbationSolution.LinearSolution_reduced_system()`](@ref)).

!!! warning
    If you change the household decision model and hence need to customize the steady state solution,
    you will need to adjust the template `Preprocessor/template_fcns/prepare_linearization.jl` and not `Preprocessor/generated_fcns/prepare_linearization_generated.jl` which will be overwritten by the model parser based on `Preprocessor/template_fcns/prepare_linearization.jl`. Note that the "definition" of the function (right click in VSCode) in the module is the generated one.


## Parameters
The model parameters for the steady state have to be calibrated. We set them
in the `struct` `ModelParameters`. It also contains all other parameters that
are estimated, including the stochastic process-parameters for the aggregate
shocks.
```@docs
ModelParameters
```
The numerical parameters contain the grid (and the meshes) on which the
stationary equilibrium is solved, discretization results of [`call_find_steadystate()`](@ref)
like the transition matrix of income and the joint distribution, and other
parameters that determine the numerical approximation or solution technique,
like `reduc` or `sol_algo`.
```@docs
NumericalParameters
```
In particular, `nh`, `nk`, and `nb` control the resolution for the income, illiquid asset, and liquid asset grid. The resolution of the copula used in the linearization does not need to coincide with that grid and is controlled by `nh_copula`, `nk_copula`, and `nb_copula`, respectively. Note, however, that the copula resolution should not exceed the actual grid size.

## Find stationary equilibrium: functions
```@docs
BASEforHANK.SteadyState.Kdiff
BASEforHANK.SteadyState.Ksupply
BASEforHANK.SteadyState.EGM_policyupdate
```

[^BBL]:
    For details, see the paper [Shocks, Frictions, and Inequality in US Business Cycles](https://www.benjaminborn.de/files/BBL_Inequality_Sep2023.pdf), *American Economic Review*, forthcoming.
[^BL]:
    For details, see the paper
    [Solving heterogeneous agent models in discrete time with many idiosyncratic states by perturbation methods](https://doi.org/10.3982/QE1243), *Quantitative Economics*, Vol.11(4), November 2020, p. 1253-1288.
