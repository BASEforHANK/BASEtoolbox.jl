# This file has been automatically generated by PreprocessInputs.jl. Any user inputs might be overwritten!




#=

Template function for Fsys_agg.jl

Explanation:
During the preprocessing step, `PreprocessInputs.jl` reads in this template file and
copies the content from `input_aggregate_model.mod` into the code block below at
the line marked with "# aggregate model marker". The code block is then written to
`FSYS_agg_generated.jl` in the `generated_fcns` directory.

=#

@doc raw"""
    Fsys_agg(X, XPrime, XSS, distrSS, m_par, n_par, indexes)

Return deviations from aggregate equilibrium conditions.

`indexes` can be both `IndexStruct` or `IndexStructAggr`; in the latter case
(which is how function is called by [`LinearSolution_reduced_system()`](@ref)), variable-vectors
`X`,`XPrime`, and `XSS` only contain the aggregate variables of the model.
"""
function Fsys_agg(
    X::AbstractArray,
    XPrime::AbstractArray,
    XSS::Array{Float64,1},
    distrSS::AbstractArray,
    m_par,
    n_par,
    indexes,
)

    ## ------------------------------------------------------------------------------------
    ## Preamble
    ## ------------------------------------------------------------------------------------

    # Initialize the output vector, use the same type as the input
    F = zeros(eltype(X), size(X))

    # Unpack X, XPrime, and XSS into variables
    @generate_equations()

    ## ------------------------------------------------------------------------------------
    ## Get the equilibrium conditions for the aggregate model (`input_aggregate_model.mod`)
    ## ------------------------------------------------------------------------------------

    # DO NOT DELETE OR EDIT NEXT LINE! This is needed for parser.


#=

This file contains the aggregate model equations. That is, everything but the household
planning problem which is described by one EGM backward step and one forward iteration of
the distribution.

Model equations take the form F[equation number] = (lhs) - (rhs)

Equation numbers are generated automatically and stored in the index struct. For this the
corresponding variable needs to be in the list of states or controls.

=#

## ----------------------------------------------------------------------------------------
## Auxiliary variables
## ----------------------------------------------------------------------------------------

# Policy reaction function to Y
YREACTION = Ygrowth

## Taxation -------------------------------------------------------------------------------

# Mass of households in each productivity state, distribution is (nb, nk, nh)
distr_h = sum(distrSS; dims = (1, 2))

## Profit shares --------------------------------------------------------------------------

# Slopes of the Phillips curve ------------------------------------------------------------
# RBC like no markup fluctuations
μ = m_par.μ
μw = m_par.μw
mcw = 1.0./m_par.μw
mc = 1.0./m_par.μ
# Demand elasticity
η = μ / (μ - 1.0)

# Demand elasticity wages
ηw = μw / (μw - 1.0)


# Marginal product of capital
MPK = interest(mc, Z, K, N, m_par) + m_par.δ_0

# Depreciation
depr = m_par.δ_0 
# Constant income risk

## ----------------------------------------------------------------------------------------
## Aggregate equations
## ----------------------------------------------------------------------------------------

## Lagged variables -----------------------------------------------------------------------

F[indexes.Ylag] = (log(YlagPrime)) - (log(Y))
F[indexes.Ilag] = (log(IlagPrime)) - (log(I))
F[indexes.wFlag] = (log(wFlagPrime)) - (log(wF))
F[indexes.Clag] = (log(ClagPrime)) - (log(C))

## Growth rates ---------------------------------------------------------------------------

F[indexes.Ygrowth] = (log(Ygrowth)) - (log(Y / Ylag))
F[indexes.Igrowth] = (log(Igrowth)) - (log(I / Ilag))
F[indexes.wgrowth] = (log(wgrowth)) - (log(wF / wFlag))
F[indexes.Cgrowth] = (log(Cgrowth)) - (log(C / Clag))

## Labor market ---------------------------------------------------------------------------

# Wages that households receive
F[indexes.wH] = (log(wH)) - (log(mcw * wF))

# Union profits
F[indexes.Π_U] = (log(Π_U)) - (log(profits_U(wF, wH, N)))

# Labor supply
F[indexes.N] =
    (log(N)) - (log(
        labor_supply(
            wH,
            Hprog,
            m_par.τlev,
            m_par.τprog,
            m_par.Tc .- 1.0,
            m_par,
            wH * N / Hprog + Π_E,
            m_par.scale_prog,
        ),
    ))
# Variables that cannot be removed even if they are constant in the model
# b/c they appear in the household problem
F[indexes.σ] = σ - m_par.σ # constant income risk, 
F[indexes.Tc] = (log(Tc)) - (log(m_par.Tc)) # constant, zero VAT
F[indexes.q] = (log(q)) - (log(1.0)) # price of capital is normalized to 1.0
# Hours-weighted average labor productivity, normalized, see equation 19b in BBL
F[indexes.Hprog] = (log(Hprog)) - XSS[indexes.HprogSS] # normalized to 1.0, still needed for labor supply function

## Production -----------------------------------------------------------------------------

# Rate of return on capital
F[indexes.RK] = (log(RK)) - (log(1 + MPK -  depr))


# Wages that firms pay
F[indexes.wF] = (log(wF)) - (log(wage(mc, Z, K, N, m_par)))

# Firm profits
F[indexes.Π_F] = (log(Π_F)) - (log(Y * (1.0 - mc) + (KPrime - (1.0 - depr) * K) - I))

# Distributed profits to entrepreneurs
F[indexes.Π_E] = log(Π_E) - log(Π_F)

# Capital accumulation equation
F[indexes.I] =
    (KPrime) - (K * (1.0 - depr) +  I )

# Production function
F[indexes.Y] = (log(Y)) - (log(output(Z, K, N, m_par)))

# TFP
F[indexes.Z] = (log(ZPrime)) - (m_par.ρ_Z * log(Z))


## Asset markets --------------------------------------------------------------------------

# Return on liquid assets equals return on capital
F[indexes.RRL] = log(RRL) - log(RK)

# Private bond return fed-funds spread (produces goods out of nothing if negative)

F[indexes.RRD] = (log(RRD)) - (log(borrowing_rate(RRL, m_par)))

## Market clearing ------------------------------------------------------------------------

# Resource constraint
F[indexes.C] = log(Y - I) - log(C)

## Additional definitions -----------------------------------------------------------------


# In one asset model, the expected liquidity premium is constant (equilibrium condition)
F[indexes.K] = K - TotalAssets # K is all Assets

## ----------------------------------------------------------------------------------------
## Closing the aggregate model, see documentation for details
## ----------------------------------------------------------------------------------------

#=

Do not delete the following lines of code!

These equations are overwritten in FSYS by the corresponding aggregation equations of
households' decisions. Here, they are simply set to close the aggregate model. This is a
trick that is exploited in the estimation when only the derivatives with respect to
aggregates is needed. These derivatives are still correct since the left-hand-side of the
equations are the same in both the purely aggregate as well as the complete model.

=#

# Scaling factor for individual productivity
F[indexes.Htilde] = (log(Htilde)) - (XSS[indexes.HtildeSS])

# Total assets
F[indexes.TotalAssets] = (log(TotalAssets)) - XSS[indexes.TotalAssetsSS]

# IOUs
F[indexes.BD] = (log(BD)) - (XSS[indexes.BDSS])

## ----------------------------------------------------------------------------------------
## Other distributional statistics
## ----------------------------------------------------------------------------------------

#=

# TO BE EXPLAINED! CURRENTLY, THESE ARE HARD-CODED IN FSYS, FIX THIS!

=#

# other distributional statistics not used in other aggregate equations and not changing
# with parameters, but potentially with other aggregate variables are NOT included here.
# They are found in FSYS.



    return F
end
