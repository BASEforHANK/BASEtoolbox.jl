#---------------------------------------------------------
# Pre-process aggregate-model and steady-state inputs and write
# them into the respective functions.
#---------------------------------------------------------

using Printf

@printf "\n"
@printf "Preprocessing Inputs...\n"

mkpath(paths["bld_example"] * "/Preprocessor/generated_fcns")

# aggregate model
model_template_file = open(paths["src"] * "/Preprocessor/template_fcns/FSYS_agg.jl")
model_template_lines = readlines(model_template_file)
insert_index = findall(x -> x == "    # aggregate model marker", model_template_lines)[1]

model_input_file = open(paths["src_example"] * "/Model/input_aggregate_model.mod")
model_input_text = read(model_input_file, String)

deblank(S::String) = filter(x -> !isspace(x), S)

touch(paths["bld_example"] * "/Preprocessor/generated_fcns/FSYS_agg_generated.jl")
open(paths["bld_example"] * "/Preprocessor/generated_fcns/FSYS_agg_generated.jl", "w") do h
    println(
        h,
        "# This file has been automatically generated by PreprocessInputs.jl. Any user inputs might be overwritten!",
    )
    println(h, "\n")

    println(h, "\n")
    for i = 1:(insert_index - 1)
        println(h, model_template_lines[i])
    end

    println(h, "\n")
    # produce replications according to magic comment
    if occursin("@R", model_input_text)
        n1 = findfirst("@R", model_input_text)
        rsym = model_input_text[n1[end] + 1]
        n2 = findfirst(r"[^\d]", model_input_text[(n1[end] + 2):end])
        n_rep = parse(Int, model_input_text[(n1[end] + 2):(n1[end] + n2[end] + 1)])
        for j = 1:n_rep
            if j == 1
                aux = ""
                write(h, model_input_text[1:(n1[1] - 1)])
                text = model_input_text[(n1[end] + n2[end] + 1):end]
            else
                aux = string(j)
                text =
                    "\n#------------------------------------------------------------------------------\n" *
                    "# Economy/Sector " *
                    string(j) *
                    " starts here" *
                    "\n#------------------------------------------------------------------------------\n" *
                    model_input_text[(n1[end] + n2[end] + 1):end]
            end

            text = replace(text, rsym => aux)
            write(h, text)
        end
    else
        write(h, model_input_text)
    end
    println(h, "\n")
    for i = (insert_index + 1):length(model_template_lines)
        println(h, model_template_lines[i])
    end
end
close(model_template_file)
close(model_input_file)

# Check number of equations
Fsys_agg_file =
    open(paths["bld_example"] * "/Preprocessor/generated_fcns/FSYS_agg_generated.jl")
Fsys_agg_lines = readlines(Fsys_agg_file)
Fsys_agg_lines_unique = unique(Fsys_agg_lines)
include(paths["src_example"] * "/Model/input_aggregate_names.jl")
variable_occurs = zeros(Bool, length(aggr_names))

for j in eachindex(aggr_names)
    if aggr_names[j] in distr_names
        variable_occurs[j] = true
    else
        variable_occurs[j] = any((
            occursin.("F[indexes." * aggr_names[j], deblank.(Fsys_agg_lines_unique)) .&
            .!(occursin.("#F[indexes." * aggr_names[j], deblank.(Fsys_agg_lines_unique)))
        ))
    end
end

variables_in_model = String[]
for line in Fsys_agg_lines_unique
    if occursin("F[indexes.", line) && !occursin("#F[indexes.", deblank(line))
        start_index = findfirst("F[indexes.", line).stop + 1
        line_chars = collect(line)
        end_index = findfirst(==(']'), line_chars[start_index:end])
        if end_index !== nothing
            push!(
                variables_in_model,
                join(line_chars[start_index:(start_index + end_index - 2)]),
            )
        end
    end
end

variables_in_model = unique(variables_in_model)
number_of_equations = length(variables_in_model)

if any(.!variable_occurs)
    @printf "The following variables do not have an error equation in the aggregate model:\n%s\n" aggr_names[.!variable_occurs]
elseif number_of_equations != (length(aggr_names) - length(distr_names))
    @warn "Warning: The number of equations in the aggregate model is not equal to the number of variables."
    if length(aggr_names) < (length(variables_in_model) + length(distr_names))
        @printf "Missing variables in the variable list (in input_aggregate_names.jl):\n%s\n" setdiff(
            variables_in_model,
            aggr_names,
        )
    else
        @printf "Variables that do not have an error equation in the aggregate model:\n%s\n" setdiff(
            aggr_names,
            variables_in_model,
        )
    end
else
    @printf "Consistency check passed:\n"
    @printf "1. All variables have an error equation.\n"
    @printf "2. All variables with an error equation are in the variable list.\n"
end

# check whether all household problem inputs (args_hh_prob_names) are in the model (aggr_names)
for name in args_hh_prob_names
    if !(name in aggr_names)
        @error "The variable $(name) is an input to the household problem but not in the aggregate names."
    end
end

# aggregate steady state
SS_template_file =
    open(paths["src"] * "/Preprocessor/template_fcns/prepare_linearization.jl")
SS_template_lines = readlines(SS_template_file)
insert_index =
    findall(x -> x == "    # aggregate steady state marker", SS_template_lines)[1]

SS_input_file = open(paths["src_example"] * "/Model/input_aggregate_steady_state.mod")
SS_input_text = read(SS_input_file, String)

touch(
    paths["bld_example"] *
    "/Preprocessor/generated_fcns/prepare_linearization_generated.jl",
)
open(
    paths["bld_example"] *
    "/Preprocessor/generated_fcns/prepare_linearization_generated.jl",
    "w",
) do h
    println(
        h,
        "# This file has been automatically generated by PreprocessInputs.jl. Any user inputs might be overwritten!",
    )
    println(h, "\n")

    for i = 1:(insert_index - 1)
        println(h, SS_template_lines[i])
    end
    println(h, "\n")
    println(h, "@set! n_par.n_agg_eqn = $number_of_equations")
    if occursin("@R", SS_input_text)
        n1 = findfirst("@R", SS_input_text)
        rsym = SS_input_text[n1[end] + 1]
        n2 = findfirst(r"[^\d]", SS_input_text[(n1[end] + 2):end])
        n_rep = parse(Int, SS_input_text[(n1[end] + 2):(n1[end] + n2[end] + 1)])
        for j = 1:n_rep
            if j == 1
                aux = ""
                text =
                    SS_input_text[1:(n1[1] - 1)] *
                    SS_input_text[(n1[end] + n2[end] + 1):end]
            else
                aux = string(j)
                text =
                    "\n#------------------------------------------------------------------------------\n" *
                    "# Economy/Sector " *
                    string(j) *
                    " starts here" *
                    "\n#------------------------------------------------------------------------------\n" *
                    SS_input_text[(n1[end] + n2[end] + 1):end]
            end
            text = replace(text, rsym => aux)
            write(h, text)
        end
    else
        write(h, SS_input_text)
    end
    println(h, "\n")
    for i = (insert_index + 1):length(SS_template_lines)
        println(h, SS_template_lines[i])
    end
end
close(SS_template_file)
close(SS_input_file)

@printf "Preprocessing Inputs... Done.\n"
